{"version":3,"file":"lonad-bundle.js","sources":["../src/utils/conditional.ts","../src/optional/optional.utils.ts","../node_modules/tslib/tslib.es6.js","../src/utils/return-this.ts","../src/generated/optional.generated.ts","../src/utils/throw-argument.ts","../src/optional/none.ts","../node_modules/lodash.flow/index.js","../src/utils/exception.ts","../src/utils/utils.ts","../src/optional/some.ts","../src/utils/factory.ts","../src/optional/optional.factory.ts","../src/optional/index.ts","../src/result/result.utils.ts","../src/generated/result.generated.ts","../src/generated/syncResult.generated.ts","../src/result/aborted.ts","../src/result/error.ts","../src/result/ok.ts","../src/generated/asyncResult.generated.ts","../src/result/pending.ts","../src/result/result.factory.ts","../src/result/index.ts"],"sourcesContent":["/**\n * Checks if the given value is an object.\n * @param value The value to check\n * @returns True if the value is an object; false otherwise.\n */\nexport function isObject(value: any): value is Record<string | number | symbol, any> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks if the given value is defined.\n * @param value The value to check\n * @returns True if the value is defined; false otherwise.\n */\nexport function isDefined<T = any>(value: any): value is T {\n  return value !== undefined;\n}\n\n/**\n * Checks if the given value is null.\n * @param value The value to check\n * @returns True if the value is null; false otherwise.\n */\nexport function isNotNull<T = any>(value: any): value is T {\n  return value !== null;\n}\n\n/**\n * Checks if the given value is not null or undefined.\n * @param value The value to check\n * @returns True if the value is not null or undefined; false otherwise.\n */\nexport function isNotNullOrUndefined<T = any>(value: any): value is T {\n  return isNotNull(value) && isDefined(value);\n}\n\n/**\n * Checks if the given object is a Promise.\n * @param object The object to check\n * @returns True if the object is a Promise; false otherwise.\n */\nexport function isPromise<T = any>(object: any): object is Promise<T> {\n  return Boolean(object && object.then);\n}\n\n/**\n * Checks if the given value is a function.\n * @param value The value to check\n * @returns True if the value is a function; false otherwise.\n */\nexport function isFunction<T = any>(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","import { Optional } from '@generated/optional.generated';\nimport { IParsedOptional } from '@src/optional.types';\nimport { isNotNullOrUndefined } from '@utils/conditional';\n\n/**\n * Wraps a given value in an Optional\n * @param value The value to wrap in an Optional\n * @returns An Optional containing the value\n * @example\n * const optional = Optional.fromNullable(1);\n * // optional === Optional.Some(1)\n *\n * const optional = Optional.fromNullable(null);\n * // optional === Optional.None()\n */\nexport function fromNullable<T>(value?: T): Optional<T> {\n  return isNotNullOrUndefined(value)\n    ? Optional.Some(value)\n    : Optional.None();\n}\n\n/**\n * Converts a parsed object to an Optional\n * @param object The parsed object to convert to an Optional\n * @returns An Optional based on the object\n * @throws Error if the object is not an Optional\n * @example\n * const someObject = { isOptionalInstance: true, valuePresent: true, value: 1 };\n * const noneObject = { isOptionalInstance: true, valueAbsent: true };\n * const notOptionalObject = { val: 88 };\n *\n * const optional = Optional.fromParsedJson(someObject);\n * // optional === Optional.Some(1)\n *\n * const optional = Optional.fromParsedJson(noneObject);\n * // optional === Optional.None()\n *\n * const optional = Optional.fromParsedJson(notOptionalObject);\n * // throws Error\n */\nexport function fromParsedJson<T>(object: IParsedOptional<T>): Optional<T> {\n  if (!isOptional(object)) {\n    throw new Error('fromParsedJson(object) expects an object obtained from JSON.parsing an Optional stringified with JSON.stringify');\n  }\n\n  return isSome(object)\n    ? Optional.Some(object.value)\n    : Optional.None();\n}\n\n/**\n * Checks if all the given optionals have a value.\n * @param optionals The optionals to combine\n * @returns An optional containing an array of the values of the optionals\n * @example\n * const optional1 = Optional.Some(1);\n * const optional2 = Optional.Some(2);\n * const optional3 = Optional.Some(3);\n * const optional4 = Optional.None();\n *\n * const optional = Optional.all([optional1, optional2, optional3]);\n * // optional === Optional.Some([1, 2, 3])\n *\n * const optional = Optional.all([optional1, optional2, optional3, optional4]);\n * // optional === Optional.None()\n */\nexport function all(optionals: Optional<any>[]): Optional<any[]> {\n  if (optionals.some(isNone)) {\n    return Optional.None();\n  }\n\n  return values(optionals);\n}\n\n/**\n * Function that returns an optional based on a truthy check\n * @param truthy The condition to test\n * @param value The value to wrap in an Optional\n * @returns An Optional containing the value if the condition is truthy, otherwise an empty Optional\n * @example\n * const optional = Optional.when(true, 1);\n * // optional === Optional.Some(1)\n *\n * const optional = Optional.when(false, 1);\n * // optional === Optional.None()\n */\nexport function when<T>(truthy: any, value?: T): Optional<T> {\n  return truthy ? Optional.Some(value) : Optional.None();\n}\n\n/**\n * Retrieves the first optional that has a value.\n * @param optionals The optionals to get the first value from\n * @returns The first optional that has a value, otherwise a none optional\n * @example\n * const optional1 = Optional.None();\n * const optional2 = Optional.Some(1);\n * const optional3 = Optional.None();\n * const optional4 = Optional.Some(3);\n *\n * const optional = Optional.first([optional1, optional2, optional3, optional4]);\n * // optional === Optional.Some(1)\n */\nexport function first(optionals: Optional<any>[]): Optional<any> {\n  const firstIndex = optionals.findIndex(isSome);\n\n  if (firstIndex === -1) {\n    return Optional.None();\n  }\n\n  return optionals[firstIndex];\n}\n\n/**\n * Combines the values of the given optionals into an array.\n * Ignores optionals that do not have a value.\n * @param optionals The optionals to combine\n * @returns An optional containing an array of the values of the optionals\n * @example\n * const optional1 = Optional.Some(1);\n * const optional2 = Optional.Some(2);\n * const optional3 = Optional.Some(3);\n * const optional4 = Optional.None();\n *\n * const optional = Optional.values([optional1, optional2, optional3, optional4]);\n * // optional === Optional.Some([1, 2, 3])\n */\nexport function values(optionals: Optional<any>[]): Optional<any[]> {\n  return Optional.Some(optionals\n    .filter(isSome)\n    .map((optional) => optional.get()));\n}\n\n/**\n * Checks if the given object is an Optional\n * @param optional The optional to check\n * @returns True if the given object is an Optional, otherwise false\n */\nexport function isOptional<T = any>(optional: any): optional is Optional<T> {\n  return Boolean(optional && optional.isOptionalInstance);\n}\n\n/**\n * Checks if the given object is an Optional and has a value\n * @param optional The optional to check\n * @returns True if the given object is an Optional and has a value, otherwise false\n * @example\n * const optional = Optional.Some(1);\n * // isSome(optional) === true\n * // isNone(optional) === false\n *\n * const optional = Optional.None();\n * // isSome(optional) === false\n * // isNone(optional) === true\n */\nexport function isSome<T = any>(optional: any): optional is Optional<T> {\n  return isOptional(optional) && optional.valuePresent;\n}\n\n/**\n * Checks if the given object is an Optional and does not have a value\n * @param optional The optional to check\n * @returns True if the given object is an Optional and does not have a value, otherwise false\n * @example\n * const optional = Optional.Some(1);\n * // isSome(optional) === true\n * // isNone(optional) === false\n *\n * const optional = Optional.None();\n * // isSome(optional) === false\n * // isNone(optional) === true\n */\nexport function isNone(optional: any): optional is Optional<any> {\n  return isOptional(optional) && optional.valueAbsent;\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","async function absorbRejectedPromises(value: Promise<any>) {\n  try {\n    await value;\n  } catch (_) {\n    // Nothing to do here.\n  }\n}\n\n\nexport default {\n  nullary: function nullaryReturnThis() {\n    return this;\n  },\n\n  unary: function unaryReturnThis(unusedArgument: any) {\n    absorbRejectedPromises(unusedArgument);\n\n    return this;\n  },\n\n  binary: function unaryReturnThis(unusedArgument: any, secondUnusedArgument: any) {\n    absorbRejectedPromises(unusedArgument);\n    absorbRejectedPromises(secondUnusedArgument);\n\n    return this;\n  },\n\n  any: function anyReturnThis(...unusedArguments: any[]) {\n    unusedArguments.forEach(absorbRejectedPromises);\n\n    return this;\n  }\n}\n","// ========================================================\n// This file is generated by optional.gen.ts\n// Do not edit this file directly\n// ========================================================\n/* eslint-disable @typescript-eslint/ban-types */\nimport { CreateSomeFunc, CreateNoneFunc, IOptional, IOptionalMatchClauses, NullableTransformationFunction, NullaryValueFactory, Predicate, SideEffectsFunction, TransformationFunction } from '@src/optional.types';\nimport { fromNullable, all, values, first, fromParsedJson, when, isOptional, isSome, isNone } from '@optional/optional.utils';\nimport { IfAnyOrUnknown, IfAny, IfNullOrUndefined } from '@utils/types';\nimport returnThis from '@utils/return-this';\nexport abstract class Optional<T = any> implements IOptional<T> {\n  isOptionalInstance = true as const;\n  valuePresent = false;\n  valueAbsent = false;\n  value?: T;\n  static Some: CreateSomeFunc;\n  static None: CreateNoneFunc;\n  static fromNullable = fromNullable;\n  static fromParsedJson = fromParsedJson;\n  static all = all;\n  static values = values;\n  static when = when;\n  static first = first;\n  static isOptional = isOptional;\n  static isSome = isSome;\n  static isNone = isNone;\n  /**\n     * Maps the value of the Optional to a new value.\n     */\n  static nullableMap: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n         */\n        <T, U = T>(λ: NullableTransformationFunction<T, U>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<U>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(λ: NullableTransformationFunction<T, U>, optional: IOptional<T>): Optional<U>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.nullableMap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).nullableMap(...params);\n    };\n  /**\n     * Returns the original optional if it is present, or the return value of the provided replacement function if the original value is not present.\n     */\n  static or: {\n        /**\n         * @param replacement A function that returns an Optional or a value that will be used as a replacement if the Optional is None.\n         */\n        <T, U = T>(replacement: any): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): any;\n        };\n        /**\n         * @param replacement A function that returns an Optional or a value that will be used as a replacement if the Optional is None.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(replacement: any, optional: IOptional<T>): any;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.or as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).or(...params);\n    };\n  /**\n     * Pattern matches on the optional value and returns the result of executing the corresponding function for the matching case.\n     */\n  static match: {\n        /**\n         * @param clauses An object containing functions to execute for the \"Some\" and \"None\" cases.\n         */\n        <T, U = undefined, V = undefined>(clauses: IOptionalMatchClauses<T, U, V>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): U | V;\n        };\n        /**\n         * @param clauses An object containing functions to execute for the \"Some\" and \"None\" cases.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = undefined, V = undefined>(clauses: IOptionalMatchClauses<T, U, V>, optional: IOptional<T>): U | V;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.match as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).match(...params);\n    };\n  /**\n     * Maps the value of the Optional to a new value.\n     */\n  static transform: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n         */\n        <T, U>(λ: TransformationFunction<T, U>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<IfAnyOrUnknown<U, any, U>>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U>(λ: TransformationFunction<T, U>, optional: IOptional<T>): Optional<IfAnyOrUnknown<U, any, U>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.transform as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).transform(...params);\n    };\n  /**\n     * Maps the value of the Optional to a new value.\n     */\n  static map: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n         */\n        <T, U>(λ: TransformationFunction<T, U>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<IfAnyOrUnknown<U, any, U>>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U>(λ: TransformationFunction<T, U>, optional: IOptional<T>): Optional<IfAnyOrUnknown<U, any, U>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.map as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).map(...params);\n    };\n  static optionalProperty: {\n        /**\n         * @param property The name of the property to retrieve.\n         */\n        <T>(property: IfAny<T, any, never>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): any;\n        };\n        /**\n         * @param property The name of the property to retrieve.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(property: IfAny<T, any, never>, optional: IOptional<T>): any;\n        <T, U extends keyof T>(property: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? T[U] : never>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U extends keyof T>(property: U, optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? T[U] : never>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.optionalProperty as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).optionalProperty(...params);\n    };\n  static nullableProperty: {\n        /**\n         * @param property The name of the property to retrieve.\n         */\n        <T>(property: IfAny<T, any, never>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<any>;\n        };\n        /**\n         * @param property The name of the property to retrieve.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(property: IfAny<T, any, never>, optional: IOptional<T>): Optional<any>;\n        <T, U extends keyof T>(property: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<IfNullOrUndefined<T[U], any, T[U]>> : never>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U extends keyof T>(property: U, optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<IfNullOrUndefined<T[U], any, T[U]>> : never>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.nullableProperty as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).nullableProperty(...params);\n    };\n  static property: {\n        /**\n         * @param property The name of the property to retrieve.\n         */\n        <T>(property: IfAny<T, any, never>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<any>;\n        };\n        /**\n         * @param property The name of the property to retrieve.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(property: IfAny<T, any, never>, optional: IOptional<T>): Optional<any>;\n        <T, U extends keyof T>(property: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<T[U]> : never>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U extends keyof T>(property: U, optional: IOptional<T>): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<T[U]> : never>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.property as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).property(...params);\n    };\n  /**\n     * Maps the value of the Optional to a new value.\n     */\n  static flatMap: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n         */\n        <T, U = T>(λ: TransformationFunction<T, U>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): any;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(λ: TransformationFunction<T, U>, optional: IOptional<T>): any;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.flatMap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).flatMap(...params);\n    };\n  /**\n     * Executes a function if the Optional is present.\n     */\n  static tap: {\n        /**\n         * @param λ A function that takes the value of the Optional and executes side effects.\n         */\n        <T>(λ: SideEffectsFunction<T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<T>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and executes side effects.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: SideEffectsFunction<T>, optional: IOptional<T>): Optional<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.tap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).tap(...params);\n    };\n  /**\n     * Checks whether the Optional satisfies a predicate.\n     */\n  static satisfies: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n         */\n        <T>(λ: Predicate<T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): boolean;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: Predicate<T>, optional: IOptional<T>): boolean;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.satisfies as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).satisfies(...params);\n    };\n  /**\n     * Checks whether the Optional's value is equal to another value.\n     */\n  static valueEquals: {\n        /**\n         * @param value The value to compare the Optional's value to.\n         */\n        <T, U = T>(value: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): boolean;\n        };\n        /**\n         * @param value The value to compare the Optional's value to.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(value: U, optional: IOptional<T>): boolean;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.valueEquals as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).valueEquals(...params);\n    };\n  /**\n     * Checks whether the Optional's value passes a predicate.\n     */\n  static filter: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n         */\n        <T>(λ: Predicate<T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<T>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: Predicate<T>, optional: IOptional<T>): Optional<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.filter as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).filter(...params);\n    };\n  /**\n     * Checks whether the Optional's value fails a predicate.\n     */\n  static reject: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n         */\n        <T>(λ: Predicate<T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: IOptional<T>): Optional<T>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a boolean.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: Predicate<T>, optional: IOptional<T>): Optional<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.reject as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).reject(...params);\n    };\n  /**\n     * Get the value or throw.\n     */\n  static get: {\n        /**\n         * @param message The message to throw if the Optional is None.\n         */\n        <T>(message: string): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): T;\n        };\n        /**\n         * @param message The message to throw if the Optional is None.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(message: string, optional: IOptional<T>): T;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.get as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).get(...params);\n    };\n  /**\n     * Get the value or return a default value.\n     */\n  static getOrElse: {\n        /**\n         * @param replacement The value to return if the Optional is None.\n         */\n        <T, U = T>(replacement: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): T | U;\n        };\n        /**\n         * @param replacement The value to return if the Optional is None.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(replacement: U, optional: IOptional<T>): T | U;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.getOrElse as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).getOrElse(...params);\n    };\n  /**\n     * Recovers from a None Optional.\n     */\n  static recover: {\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n         */\n        <T, U = T>(λ: NullaryValueFactory<U>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): Optional<U>;\n        };\n        /**\n         * @param λ A function that takes the value of the Optional and returns a new value.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(λ: NullaryValueFactory<U>, optional: IOptional<T>): Optional<U>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.recover as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).recover(...params);\n    };\n  /**\n     * Replace the value of the Optional.\n     */\n  static replace: {\n        /**\n         * @param value The value to replace the Optional's value with.\n         */\n        <T, U = T>(value: U): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: IOptional<T>): Optional<U>;\n        };\n        /**\n         * @param value The value to replace the Optional's value with.\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, U = T>(value: U, optional: IOptional<T>): Optional<U>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Optional.replace as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? (<any>Optional.Some)()).replace(...params);\n    }; /**\n* Maps the value of the Optional to a new value.\n* @param λ A function that takes the value of the Optional and returns a new value.\n* @returns An Optional containing the new value.\n* @example\n* const optional = Optional.Some(5);\n* const newOptional = optional.nullableMap(x => x + 1);\n* // newOptional === Optional.Some(6)\n*\n* const optional = Optional.Some(5);\n* const newOptional = optional.nullableMap(x => undefined);\n* // newOptional === Optional.None()\n*\n* const optional = Optional.None();\n* const newOptional = optional.nullableMap(x => x + 1);\n* // newOptional === Optional.None()\n*/\n  nullableMap<U = T>(λ: NullableTransformationFunction<T, U>): Optional<U>;\n  nullableMap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Returns the original optional if it is present, or the return value of the provided replacement function if the original value is not present.\n       * @param replacement A function that returns an Optional or a value that will be used as a replacement if the Optional is None.\n       * @returns The original Optional if it is present, or the return value of the provided replacement function if the original value is not present.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.or(() => Optional.Some(6));\n       * // result === Optional.Some(5)\n       *\n       * const none = Optional.None();\n       * const result = none.or(() => Optional.Some(6));\n       * // result === Optional.Some(6)\n       */ or<U = T>(replacement: (() => Optional<U>) | Optional<U>): Optional<T> | Optional<U>;\n  or(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Pattern matches on the optional value and returns the result of executing the corresponding function for the matching case.\n       * @param clauses An object containing functions to execute for the \"Some\" and \"None\" cases.\n       * @returns The result of executing the matching function.\n       */ match<U = undefined, V = undefined>(clauses: IOptionalMatchClauses<T, U, V>): U | V;\n  match(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a new value.\n       * @param λ A function that takes the value of the Optional and returns a new value.\n       * @see Alias for {@link map}\n       */ transform<U>(λ: TransformationFunction<T, U>): Optional<IfAnyOrUnknown<U, any, U>>;\n  transform(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a new value.\n       * @param λ A function that takes the value of the Optional and returns a new value.\n       * @returns An Optional containing the new value.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.map(x => `Result - ${x}`);\n       * // result === Optional.Some(\"Result - 5\")\n       *\n       * const none = Optional.None();\n       * const result = none.map(x => `Result - ${x}`);\n       * // result === Optional.None()\n       */ map<U>(λ: TransformationFunction<T, U>): Optional<IfAnyOrUnknown<U, any, U>>;\n  map(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a property of the value.\n       * @param property The name of the property to retrieve.\n       * @returns The value of the property or an None Optional.\n       * @example\n       * const some = Optional.Some({ name: \"John\", age: 30 });\n       * const result = some.property(\"name\");\n       * // result === \"John\"\n       *\n       * const none = Optional.None();\n       * const result = none.property(\"name\");\n       * // result === Optional.None()\n       */ optionalProperty(property: IfAny<T, any, never>): any;\n  optionalProperty<U extends keyof T>(property: U): IfAnyOrUnknown<T, Optional, U extends keyof T ? T[U] : never>;\n  optionalProperty(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a property of the value.\n       * Wraps the value in an Optional.\n       * @param property The name of the property to retrieve.\n       * @returns An Optional containing the value of the property.\n       * @example\n       * const some = Optional.Some({ name: \"John\", age: 30 });\n       * const result = some.nullableProperty(\"name\");\n       * // result === Optional.Some(\"John\")\n       *\n       * const some = Optional.Some({ name: \"John\", age: 30 });\n       * const result = some.nullableProperty(\"nonExistentProperty\");\n       * // result === Optional.None()\n       *\n       * const none = Optional.None();\n       * const result = none.nullableProperty(\"name\");\n       * // result === Optional.None()\n       */ nullableProperty(property: IfAny<T, any, never>): Optional<any>;\n  nullableProperty<U extends keyof T>(property: U): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<IfNullOrUndefined<T[U], any, T[U]>> : never>;\n  nullableProperty(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a property of the value.\n       * Wraps the value in an Some Optional.\n       * @param property The name of the property to retrieve.\n       * @returns An Optional containing the value of the property.\n       * @example\n       * const some = Optional.Some({ name: \"John\", age: 30 });\n       * const result = some.property(\"name\");\n       * // result === Optional.Some(\"John\")\n       *\n       * const some = Optional.Some({ name: \"John\", age: 30 });\n       * const result = some.property(\"nonExistentProperty\");\n       * // result === Optional.Some(undefinied)\n       *\n       * const none = Optional.None();\n       * const result = none.property(\"name\");\n       * // result === Optional.None()\n       */ property(property: IfAny<T, any, never>): Optional<any>;\n  property<U extends keyof T>(property: U): IfAnyOrUnknown<T, Optional, U extends keyof T ? Optional<T[U]> : never>;\n  property(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Maps the value of the Optional to a new value.\n       * @param λ A function that takes the value of the Optional and returns a new value.\n       * @returns Either the new value or itself if the Optional is None.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.flatMap(x => `Result - ${x}`);\n       * // result === \"Result - 5\"\n       *\n       * const none = Optional.None();\n       * const result = none.flatMap(x => `Result - ${x}`);\n       * // result === Optional.None()\n       */ flatMap<U = T>(λ: TransformationFunction<T, U>): U | Optional<any>;\n  flatMap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Executes a function if the Optional is present.\n       * @param λ A function that takes the value of the Optional and executes side effects.\n       * @returns The Optional itself.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.tap(x => console.log(x)); // logs: 5\n       * // result === Optional.Some(5)\n       *\n       * const none = Optional.None();\n       * const result = none.tap(x => console.log(x)); // does not log\n       * // result === Optional.None()\n       */ tap(λ: SideEffectsFunction<T>): Optional<T>;\n  tap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Checks whether the Optional satisfies a predicate.\n       * @param λ A function that takes the value of the Optional and returns a boolean.\n       * @returns True if the predicate returns true, false otherwise.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.satisfies(x => x > 4);\n       * // result === true\n       *\n       * const some = Optional.Some(5);\n       * const result = some.satisfies(x => x > 6);\n       * // result === false\n       *\n       * const none = Optional.None();\n       * const result = none.satisfies(x => x > 4);\n       * // result === false\n       */ satisfies(λ: Predicate<T>): boolean;\n  satisfies(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Checks whether the Optional's value is equal to another value.\n       * @param value The value to compare the Optional's value to.\n       * @returns True if the values are equal, false otherwise.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.valueEquals(5);\n       * // result === true\n       *\n       * const some = Optional.Some(5);\n       * const result = some.valueEquals(\"some string\");\n       * // result === false\n       *\n       * const none = Optional.None();\n       * const result = none.valueEquals(5);\n       * // result === false\n       */ valueEquals<U = T>(value: U): boolean;\n  valueEquals(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Checks whether the Optional's value passes a predicate.\n       * @param λ A function that takes the value of the Optional and returns a boolean.\n       * @see {@link reject} for the opposite of this method.\n       * @returns Itself if the predicate returns true, `Optional.None()` otherwise.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.filter(x => x > 4);\n       * // result === Optional.Some(5)\n       *\n       * const some = Optional.Some(5);\n       * const result = some.filter(x => x > 6);\n       * // result === Optional.None()\n       *\n       * const none = Optional.None();\n       * const result = none.filter(x => x > 4);\n       * // result === Optional.None()\n       */ filter(λ: Predicate<T>): Optional<T>;\n  filter(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Checks whether the Optional's value fails a predicate.\n       * @param λ A function that takes the value of the Optional and returns a boolean.\n       * @see {@link filter} for the opposite of this method.\n       * @returns Itself if the predicate returns false, `Optional.None()` otherwise.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.reject(x => x > 4);\n       * // result === Optional.None()\n       *\n       * const some = Optional.Some(5);\n       * const result = some.reject(x => x > 6);\n       * // result === Optional.Some(5)\n       *\n       * const none = Optional.None();\n       * const result = none.reject(x => x > 4);\n       * // result === Optional.None()\n       */ reject(λ: Predicate<T>): Optional<T>;\n  reject(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Get the value or throw.\n       * @param message The message to throw if the Optional is None.\n       * @returns The value of the Optional.\n       * @throws If the Optional is None.\n       * @example\n       * const some = Optional.Some(5);\n       * const result = some.get();\n       * // result === 5\n       *\n       * const none = Optional.None();\n       * const result = none.get(\"No value present\");\n       * // throws: \"No value present\"\n       */ get(message?: string): T;\n  get(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Get the value or return a default value.\n       * @param replacement The value to return if the Optional is None.\n       * @returns The value of the Optional or the default value.\n       * @example\n       * const some = Optional.Some(10);\n       * const result = some.getOrElse(5);\n       * // result === 10\n       *\n       * const none = Optional.None();\n       * const result = none.getOrElse(5);\n       * // result === 5\n       */ getOrElse<U = T>(replacement?: U): T | U;\n  getOrElse(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Recovers from a None Optional.\n       * @param λ A function that takes the value of the Optional and returns a new value.\n       * @returns Itself if the Optional is Some, a new Optional with the result of the function otherwise.\n       * @example\n       * const some = Optional.Some(10);\n       * const result = some.recover(() => 5);\n       * // result === Optional.Some(10)\n       *\n       * const none = Optional.None();\n       * const result = none.recover(() => 5);\n       * // result === Optional.Some(5)\n       */ recover<U = T>(λ: NullaryValueFactory<U>): Optional<U>;\n  recover(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n       * Replace the value of the Optional.\n       * @param value The value to replace the Optional's value with.\n       * @note This method does not recover from a None Optional.\n       * @returns A new Optional with the new value.\n       * @example\n       * const some = Optional.Some(10);\n       * const result = some.replace(5);\n       * // result === Optional.Some(5)\n       *\n       * const none = Optional.None();\n       * const result = none.replace(5);\n       * // result === Optional.None()\n       */ replace<U = T>(value: U): Optional<U>;\n  replace(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n}\n","export default (argument: any) => {\n  throw argument;\n};\n","import { Optional } from '@generated/optional.generated';\nimport {\n  IOptionalMatchClauses,\n  NoneType,\n  NullaryValueFactory,\n  Predicate,\n} from '@src/optional.types';\n\nimport throwArgument from '@utils/throw-argument';\nimport { isFunction } from '@utils/conditional';\n\nexport class NoneClass extends Optional<any> implements NoneType {\n  valueAbsent = true as const;\n  valuePresent = false as const;\n\n  constructor(){\n    super();\n  }\n\n  or<U>(replacement: (() => Optional<U>) | Optional<U>): Optional<U> {\n    return (isFunction(replacement))\n      ? replacement()\n      : replacement;\n  }\n\n  match<U, V>(clauses: IOptionalMatchClauses<any, U, V>): U | V {\n    return (clauses.None || throwArgument)(undefined);\n  }\n\n  satisfies(λ: Predicate<any>): boolean {\n    return false;\n  }\n\n  valueEquals(): boolean {\n    return false;\n  }\n\n  get(message?: string): never {\n    throw new Error(message || 'Cannot unwrap None instances');\n  }\n\n  getOrElse<U>(replacement?: U): U;\n  getOrElse(replacement?: any): any {\n    return replacement;\n  }\n\n  recover<U>(λ: NullaryValueFactory<U>): Optional<U> {\n    return Optional.Some(λ());\n  }\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Creates a `_.flow` or `_.flowRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new flow function.\n */\nfunction createFlow(fromRight) {\n  return baseRest(function(funcs) {\n    funcs = baseFlatten(funcs, 1);\n\n    var length = funcs.length,\n        index = length;\n\n    if (fromRight) {\n      funcs.reverse();\n    }\n    while (index--) {\n      if (typeof funcs[index] != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n    }\n    return function() {\n      var index = 0,\n          result = length ? funcs[index].apply(this, arguments) : arguments[0];\n\n      while (++index < length) {\n        result = funcs[index].call(this, result);\n      }\n      return result;\n    };\n  });\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates a function that returns the result of invoking the given functions\n * with the `this` binding of the created function, where each successive\n * invocation is supplied the return value of the previous.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Util\n * @param {...(Function|Function[])} [funcs] The functions to invoke.\n * @returns {Function} Returns the new composite function.\n * @see _.flowRight\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * var addSquare = _.flow([_.add, square]);\n * addSquare(1, 2);\n * // => 9\n */\nvar flow = createFlow();\n\nmodule.exports = flow;\n","export default Error;\n","import pipe from 'lodash.flow';\nimport Exception from './exception';\nimport { isDefined, isFunction } from './conditional';\n\nexport const identity = <T>(x: T) => x;\nexport const constant = <T>(x: T) => () => x;\nexport const property = <T>(propertyName: keyof T) => (object: T) => object[propertyName];\n\n/**\n * Asserts that the given value is defined.\n * @param value The value to check\n * @param message The error message to throw if the value is not defined\n * @throws Error if the value is not defined\n */\nexport function assertIsDefined<T = any>(value: T, message?: string): asserts value is NonNullable<T> {\n  if (!isDefined(value)) {\n    throw new Exception(message ?? 'Value is not defined');\n  }\n}\n/**\n * Asserts that the given value is a function.\n * @param value The value to check\n * @param message  The error message to throw if the value is not a function\n */\nexport function assertIsFunction<T = any>(value: T, message?: string): asserts value is T {\n  if (!isFunction(value)) {\n    throw new Exception(message ?? 'Value is not a function');\n  }\n}\n\nexport { pipe };\n","import { Optional } from '@generated/optional.generated';\nimport {\n  IOptionalMatchClauses,\n  NullableTransformationFunction,\n  Predicate,\n  SideEffectsFunction,\n  SomeType,\n  TransformationFunction,\n} from '@src/optional.types';\n\nimport { identity } from '@utils/utils';\nimport { isObject } from '@utils/conditional';\n\nexport class SomeClass<T> extends Optional<T> implements SomeType<T> {\n  valuePresent = true as const;\n  valueAbsent = false as const;\n\n  value: T;\n\n  constructor(someValue?: T) {\n    super();\n    this.value = someValue!;\n  }\n\n  nullableMap<U>(λ: NullableTransformationFunction<T, U>): Optional<U> {\n    return Optional.fromNullable(λ(this.value)) as any;\n  }\n\n  match<U, V>(clauses: IOptionalMatchClauses<T, U, V>): U | V {\n    return (clauses.Some || identity)(<any> this.value);\n  }\n\n  transform<U>(λ: TransformationFunction<T, U>): Optional<U> {\n    return this.map(λ);\n  }\n\n  map<U>(λ: TransformationFunction<T, U>): Optional<U> {\n    return Optional.Some(λ(this.value));\n  }\n\n  optionalProperty(property: string | symbol | number): any {\n    return isObject(this.value) ? this.value[property] : undefined;\n  }\n\n\n  nullableProperty(property: string | symbol | number): any {\n    return Optional.fromNullable(isObject(this.value) ? this.value[property] : undefined);\n  }\n\n  flatMap<U>(λ: TransformationFunction<T, U>): U {\n    return λ(this.value);\n  }\n\n  tap(λ: SideEffectsFunction<T>): Optional<T> {\n    λ(this.value);\n\n    return this;\n  }\n\n  property(property: string | symbol | number): any {\n    return Optional.Some(isObject(this.value) ? this.value[property] : undefined);\n  }\n\n  satisfies(λ: Predicate<T>): boolean {\n    return Boolean(λ(this.value));\n  }\n\n  valueEquals(value: T): boolean;\n  valueEquals<U>(value: U): boolean;\n  valueEquals(value: any): boolean {\n    return this.value === value;\n  }\n\n  filter(λ: Predicate<T>): Optional<T> {\n    return λ(this.value) ? this : Optional.None();\n  }\n\n  reject(λ: Predicate<T>): Optional<T> {\n    return !λ(this.value) ? this : Optional.None();\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  getOrElse(replacement?: any): any {\n    return this.value;\n  }\n\n  replace<U>(value: U): Optional<U> {\n    return Optional.Some(value);\n  }\n}\n","interface IPrototype { prototype: any; }\n\ntype Constructor<T = any> = new (...args: any[]) => T;\n\n/**\n * Function assigns the prototype of the patch to the target object.\n * @param objectToPatch The object to patch\n * @param patch The prototype patch to apply\n */\nexport function patchPrototype<T extends IPrototype, Y extends Constructor>(objectToPatch: T, patch: Y): void {\n  const oldPrototype = objectToPatch.prototype;\n  objectToPatch.prototype = Object.create(patch.prototype);\n  return Object.assign(objectToPatch.prototype, oldPrototype);\n}\n\n/**\n * Function instantiates an object and assigns the prototype of the factory to the new object.\n * @param constructor The constructor to instantiate\n * @param factory The factory function to use\n * @param args The arguments to pass to the constructor\n * @returns An instance of the constructor\n */\nexport function instantiateWithFactory<T extends Constructor>(\n  constructor: T,\n  factory: IPrototype,\n  ...args: ConstructorParameters<T>\n): InstanceType<T> {\n  const newInstance = new constructor(...args);\n  Object.setPrototypeOf(newInstance, factory.prototype);\n  return newInstance;\n}\n","import { patchPrototype, instantiateWithFactory } from '@utils/factory';\nimport { NoneClass } from './none';\nimport { SomeClass } from './some';\n\n/**\n * Patch the function prototypes to inherit from their respective\n * Class prototypes\n */\nfunction patchFactoryFunctions() {\n  patchPrototype(Some, SomeClass);\n  patchPrototype(None, NoneClass);\n}\n\n\nexport const Some = function makeSome<T>(value?: T): SomeClass<T> {\n  return instantiateWithFactory(SomeClass<T>, Some, value);\n};\n\nexport const None = function makeNone(): NoneClass {\n  return instantiateWithFactory(NoneClass, None);\n};\n\npatchFactoryFunctions();\n","import { Optional } from '@generated/optional.generated';\nimport { NoneClass } from './none';\nimport { SomeClass } from './some';\nimport { None, Some } from './optional.factory';\n\nfunction addStaticProperties() {\n  Optional.Some = Some;\n  Optional.None = None;\n}\n\naddStaticProperties();\n\nexport {\n  SomeClass,\n  NoneClass,\n\n  Optional,\n};\n","/* eslint-disable @typescript-eslint/ban-types */\nimport { AsyncResult } from '@generated/asyncResult.generated';\nimport { Result } from '@generated/result.generated';\nimport { SyncResult } from '@generated/syncResult.generated';\nimport { Optional } from '@optional/index';\nimport { isOptional } from '@optional/optional.utils';\nimport { IfAnyOrUnknown } from '@utils/types';\nimport { constant, identity, pipe } from '@utils/utils';\nimport { isNotNullOrUndefined, isObject, isPromise } from '@utils/conditional';\n\n/**\n * Function that transforms a value into a result\n * @param λ The transformation function\n * @param wrapFunction The function that wraps the result of the transformation function\n * @param thisArg The context of the transformation function\n * @returns The result of the wrapped transformation function.\n * @example\n * const result = TransformResult(() => 2, Result.Ok);\n * // result === Result.Ok(2)\n *\n * const result = TransformResult((x) => x + 2, Result.Ok, 1);\n * // result === Result.Ok(3)\n *\n * const result = TransformResult(() => 5);\n * // result === 5\n */\nexport function TransformResult<I, O = any, T extends Result<any> = Result>(\n  λ: (x?: T) => Promise<I> | I,\n  wrapFunction: ((x: I) => O) = <any>identity,\n  thisArg?: T\n) : Result<O> | O {\n  try {\n    const value = λ(thisArg);\n\n    if (isPromise(value)) {\n      return Result.Pending(value.then(wrapFunction, Result.Aborted));\n    }\n\n    return wrapFunction(value);\n  } catch (error) {\n    return Result.Aborted(error);\n  }\n}\n\n\nexport function doTry<T = any>(λ: () => PromiseLike<Optional<T>> | PromiseLike<T>): AsyncResult<T>\nexport function doTry<T = any>(λ: () => Optional<T> | T) : SyncResult<T>;\nexport function doTry<T = any>(λ: () => any) : Result<T> {\n  return TransformResult(λ, (value: any) => {\n    if (isResult<T>(value)) {\n      return value;\n    }\n\n    let optional = value;\n    if (!value || !isOptional<T>(value)) {\n      optional = Optional.fromNullable<T>(value);\n    }\n\n    return (optional as Optional<T>).match({\n      Some: Result.Ok,\n      None: constant(Result.Error())\n    });\n  }) as Result<T>;\n}\n\nexport function tryAsync<T = any>(λ: (x: Result<T>) => PromiseLike<T> | PromiseLike<Optional<T>>): AsyncResult<T>\nexport function tryAsync<T = any>(λ: (x: Result<T>) => Optional<T> | T): AsyncResult<T>;\nexport function tryAsync<T = any>(λ: (x: Result<T>) => PromiseLike<T> | PromiseLike<Optional<T>> | Optional<T> | T): AsyncResult<T> {\n  return <any>pipe(doTry, Result.asynchronous)(<any>λ);\n}\n\n/**\n * Function that returns a result based on a truthy check\n * @param truthy The truthy value\n * @param value The value to return if truthy\n * @param error The error to return if falsy\n * @returns The result of the truthy check\n */\nexport function when<T, Y>(truthy: any, value?: T, error?: Y): SyncResult<any> {\n  return truthy ? Result.Ok(value) : Result.Error(error);\n}\n\n/**\n * Function that returns a async result based on a given promise\n * @param promise The promise to convert to a result\n * @returns A AsyncResult based on the promise\n */\nexport function fromPromise<T = any>(promise: Promise<T>): AsyncResult<T> {\n  return Result.Pending(isPromise(promise) ? promise.then(Result.Ok, Result.Error) : Result.Error() as any);\n}\n\n/**\n * Function that returns a result based on a given value\n * @param value The value to convert to a result\n * @returns A Result based on the value\n * @example\n * const result = expect(1);\n * // result === Result.Ok(1)\n *\n * const result = expect(null);\n * // result === Result.Error()\n *\n * const result = expect(Optional.Some(1));\n * // result === Result.Ok(1)\n *\n * const result = expect(Optional.None());\n * // result === Result.Error()\n *\n * const result = expect(Result.Ok(1));\n * // result === Result.Ok(1)\n *\n * const result = expect(Promise.resolve(1));\n * // result === Result.Pending(1)\n */\nexport function expect<T = any>(value: PromiseLike<Optional<T>>): AsyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: Optional<T>): SyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: SyncResult<T>): SyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: Result<T>): Result<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: PromiseLike<T>): AsyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: T): SyncResult<IfAnyOrUnknown<T, any, T & {}>>;\nexport function expect<T = any>(value: Optional<T> | Result<T> | PromiseLike<T> | T): Result<T> | T {\n  if (!isNotNullOrUndefined(value)) {\n    return Result.Error();\n  }\n\n  if (!isObject(value)) {\n    return Result.Ok(value);\n  }\n\n  if (isPromise(value)) {\n    return Result.Pending(value.then(\n      expect,\n      Result.Aborted\n    ));\n  }\n\n  if (isResult(value)) {\n    return value;\n  }\n\n  const optionalObject = (!isOptional<T>(value))\n    ? Optional.fromNullable(<T>value)\n    : value;\n\n  return optionalObject.match({\n    Some: (e) => Result.Ok(e),\n    None: Result.Error\n  });\n}\n\n/**\n * Function tests if an object is a Result\n * @param object The object to check\n * @returns True if the object is a Result\n * @example\n * const result = isResult(Result.Ok(1));\n * // result === true\n *\n * const result = isResult(Result.Error());\n * // result === true\n *\n * const result = isResult(5);\n * // result === false\n */\nexport function isResult<T = any>(object: any): object is Result<T> {\n  return Boolean(object && object.isResultInstance);\n}\n\n/**\n * Function tests if an object is a SyncResult\n * @param object The object to check\n * @returns True if the object is a SyncResult\n * @example\n * const result = isSyncResult(Result.Ok(1));\n * // result === true\n *\n * const result = isSyncResult(Result.Pending(1));\n * // result === false\n *\n * const result = isSyncResult(5);\n * // result === false\n */\nexport function isSyncResult<T = any>(object: any): object is SyncResult<T> {\n  return isResult<T>(object) && (<any>object).isAsynchronous === false;\n}\n\n/**\n * Function tests if an object is a AsyncResult\n * @param object The object to check\n * @returns True if the object is a AsyncResult\n * @example\n * const result = isAsyncResult(Result.Ok(1));\n * // result === false\n *\n * const result = isAsyncResult(Result.Pending(1));\n * // result === true\n *\n * const result = isAsyncResult(5);\n * // result === false\n */\nexport function isAsyncResult<T = any>(object: any): object is AsyncResult<T> {\n  return isResult<T>(object) && (<any>object).isAsynchronous === true;\n}\n","// ========================================================\n// This file is generated by result.gen.ts\n// Do not edit this file directly\n// ========================================================\n/* eslint-disable @typescript-eslint/ban-types */\nimport { IResult, IResultCallbacks, createOkType, createErrorType, createAbortedType, createPendingType } from '@src/result.types';\nimport { doTry, expect, fromPromise, tryAsync, when, isResult, isSyncResult, isAsyncResult } from '@result/result.utils';\nimport { Optional } from '@optional/index';\nimport { AsyncResult } from './asyncResult.generated';\nimport { SyncResult } from './syncResult.generated';\nimport { IfAnyOrUnknown, IfAny } from '@utils/types';\n/**\n * The base class for all results.\n * The Result class is a combination of both the SyncResult\n * and AsyncResult classes. As such it can be used as a base.\n * @example\n * const syncResult = Result.Ok(1); // SyncResult<number>\n * const result = syncResult as Result<number>; // Result<number>\n * const returnedResult = result.get(); // number | Promise<number>\n *\n * // result is now a Result<number> which can be a SyncResult<number> or an\n * //   AsyncResult<number>. It is not known which one it is. Thus when\n * //   calling functions on it, the return type will be a union of both.\n */\nexport abstract class Result<T = any> implements IResult<T> {\n  isResultInstance = true as const;\n  isAsynchronous = false;\n  isOk = false;\n  isError = false;\n  isAborted = false;\n  static Ok: createOkType;\n  static Error: createErrorType;\n  static Aborted: createAbortedType;\n  static Pending: createPendingType;\n  static fromPromise = fromPromise;\n  static when = when;\n  static expect = expect;\n  static try = doTry;\n  static tryAsync = tryAsync;\n  static isResult = isResult;\n  static isSyncResult = isSyncResult;\n  static isAsyncResult = isAsyncResult;\n  /**\n     * Returns the value of the result.\n * If the result is not Ok, it will throw an error.\n     */\n  static get: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): Promise<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): T;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): T | Promise<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.get as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).get(...params);\n    };\n  /**\n     * Returns the value of the result.\n * If the result is not Ok, it will return the value provided.\n     */\n  static getOrElse: {\n        /**\n         * @param value The value to return if the result is not Ok\n         */\n        <T, Y = T>(value: Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Promise<T> | Promise<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): T | Y;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): T | Promise<T> | Y | Promise<Y>;\n        };\n        /**\n         * @param value The value to return if the result is not Ok\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: AsyncResult<T>): Promise<T> | Promise<Y>;\n        /**\n         * @param value The value to return if the result is not Ok\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: SyncResult<T>): T | Y;\n        /**\n         * @param value The value to return if the result is not Ok\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: Result<T>): T | Promise<T> | Y | Promise<Y>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.getOrElse as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).getOrElse(...params);\n    };\n  /**\n     * Recovers from an error if an error occurs.\n     */\n  static recover: {\n        /**\n         * @param λ The function to recover with\n         */\n        <T, R = T>(λ: (x: any) => PromiseLike<R>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): AsyncResult<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): AsyncResult<T | R>;\n        };\n        /**\n         * @param λ The function to recover with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => PromiseLike<R>, optional: AsyncResult<T>): AsyncResult<T | R>;\n        <T, R = T>(λ: (x: any) => R): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<T | R>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<T | R>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: AsyncResult<T>): AsyncResult<T | R>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: AsyncResult<T>): Result<T | R>;\n        /**\n         * @param λ The function to recover with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => PromiseLike<R>, optional: SyncResult<T>): AsyncResult<T | R>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: SyncResult<T>): SyncResult<T | R>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: SyncResult<T>): Result<T | R>;\n        /**\n         * @param λ The function to recover with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => PromiseLike<R>, optional: Result<T>): AsyncResult<T | R>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, R = T>(λ: (x: any) => R, optional: Result<T>): Result<T | R>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.recover as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).recover(...params);\n    };\n  /**\n     * Replace the value of the result.\n * Will only replace the value if the result is Ok.\n     */\n  static replace: {\n        /**\n         * @param value The value to replace the result with\n         */\n        <T, Y = T>(value: PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): AsyncResult<Y>;\n        };\n        /**\n         * @param value The value to replace the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(value: Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(value: Y | PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<Y>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y | PromiseLike<Y>, optional: AsyncResult<T>): Result<Y>;\n        /**\n         * @param value The value to replace the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: SyncResult<T>): SyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y | PromiseLike<Y>, optional: SyncResult<T>): Result<Y>;\n        /**\n         * @param value The value to replace the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: PromiseLike<Y>, optional: Result<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(value: Y | PromiseLike<Y>, optional: Result<T>): Result<Y>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.replace as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).replace(...params);\n    };\n  /**\n     * Returns the wrapped property value if the result contains an object.\n * Will return an Error result if the property was not found.\n     */\n  static expectProperty: {\n        <T>(propertyName: IfAny<T, any, never>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<any>;\n        };\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: AsyncResult<T>): AsyncResult<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: AsyncResult<T>): Result<any>;\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: AsyncResult<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: SyncResult<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(optional: Result<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: AsyncResult<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: SyncResult<T>): SyncResult<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: SyncResult<T>): Result<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: SyncResult<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: Result<T>): Result<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y, optional: Result<T>): Result<IfAnyOrUnknown<V, any, V & {}>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.expectProperty as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).expectProperty(...params);\n    };\n  /**\n     * Returns the wrapped property value if the result contains an object.\n * Will always return an Ok result even if the property was not found.\n     */\n  static property: {\n        <T>(propertyName: IfAny<T, any, never>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<any>;\n        };\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: AsyncResult<T>): AsyncResult<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: AsyncResult<T>): Result<any>;\n        <T, Y extends keyof T>(propertyName: Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<Y extends keyof T ? T[Y] : any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<Y extends keyof T ? T[Y] : any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<Y extends keyof T ? T[Y] : any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<Y extends keyof T ? T[Y] : any>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<Y extends keyof T ? T[Y] : any>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: AsyncResult<T>): AsyncResult<Y extends keyof T ? T[Y] : any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: AsyncResult<T>): Result<Y extends keyof T ? T[Y] : any>;\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: SyncResult<T>): SyncResult<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: SyncResult<T>): Result<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: SyncResult<T>): SyncResult<Y extends keyof T ? T[Y] : any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: SyncResult<T>): Result<Y extends keyof T ? T[Y] : any>;\n        /**\n         * @param propertyName The name of the property to get\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(propertyName: IfAny<T, any, never>, optional: Result<T>): Result<any>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y extends keyof T>(propertyName: Y, optional: Result<T>): Result<Y extends keyof T ? T[Y] : any>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.property as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).property(...params);\n    };\n  /**\n     * Tap into the result and perform an action.\n * Will only perform the action if the result is Ok.\n     */\n  static tap: {\n        /**\n         * @param λ The action to perform\n         */\n        <T>(λ: (x: T) => PromiseLike<void>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param λ The action to perform\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => PromiseLike<void>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(λ: (x: T) => void): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(λ: (x: T) => void | PromiseLike<void>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void | PromiseLike<void>, optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param λ The action to perform\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => PromiseLike<void>, optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void, optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void | PromiseLike<void>, optional: SyncResult<T>): Result<T>;\n        /**\n         * @param λ The action to perform\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => PromiseLike<void>, optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: T) => void | PromiseLike<void>, optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.tap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).tap(...params);\n    };\n  /**\n     * Test if the result satisfies a predicate.\n * Will only test the predicate if the result is Ok.\n     */\n  static satisfies: {\n        /**\n         * @param predicate The predicate to test\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean | T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Promise<boolean>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Promise<boolean>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Promise<boolean>;\n        };\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean | T>, optional: AsyncResult<T>): Promise<boolean>;\n        <T>(predicate: (x: T) => boolean | T): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Promise<boolean>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): boolean;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): boolean | Promise<boolean>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | T, optional: AsyncResult<T>): Promise<boolean>;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean | T>, optional: SyncResult<T>): Promise<boolean>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | T, optional: SyncResult<T>): boolean;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean | T>, optional: Result<T>): Promise<boolean>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | T, optional: Result<T>): boolean | Promise<boolean>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.satisfies as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).satisfies(...params);\n    };\n  /**\n     * Test if the result value equals another value.\n * Will only test the equality if the result is Ok.\n     */\n  static valueEquals: {\n        /**\n         * @param value The value to test equality with\n         */\n        <T>(value: T): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Promise<boolean>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): boolean;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): boolean | Promise<boolean>;\n        };\n        /**\n         * @param value The value to test equality with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(value: T, optional: AsyncResult<T>): Promise<boolean>;\n        /**\n         * @param value The value to test equality with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(value: T, optional: SyncResult<T>): boolean;\n        /**\n         * @param value The value to test equality with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(value: T, optional: Result<T>): boolean | Promise<boolean>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.valueEquals as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).valueEquals(...params);\n    };\n  /**\n     * Map the result value.\n * Will only map the value if the result is Ok.\n * Will always return an Ok result even if the passed value is undefined.\n     */\n  static map: {\n        /**\n         * @param λ The function to map the value to\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        };\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        <T, Y = T>(λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.map as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).map(...params);\n    };\n  /**\n     * Map the result value.\n * Will only map the value if the result is Ok.\n * Will always return an Ok result even if the passed value is undefined.\n     */\n  static transform: {\n        /**\n         * @param λ The function to map the value to\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        };\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        <T, Y = T>(λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.transform as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).transform(...params);\n    };\n  /**\n     * Map the result value.\n * Will only map the value if the result is Ok.\n * Will return an Error result if the passed value is undefined.\n     */\n  static expectMap: {\n        /**\n         * @param λ The function to map the value to\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<T>>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<T>>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Optional<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Result<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<T>>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param λ The function to map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<T>>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y | PromiseLike<Y>, optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.expectMap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).expectMap(...params);\n    };\n  /**\n     * Map the result value and flatten the result.\n * Will only map the value if the result is Ok.\n     */\n  static flatMap: {\n        /**\n         * @param λ The function to flat map the value to\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param λ The function to flat map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => PromiseLike<Result<Y>>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Result<Y>>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Optional<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: AsyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Result<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: AsyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        <T, Y = T>(λ: (x: T) => any): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(optional: AsyncResult<T>): Result<Y & {}>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(optional: SyncResult<T>): Result<Y & {}>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<Y & {}>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => any, optional: AsyncResult<T>): Result<Y & {}>;\n        /**\n         * @param λ The function to flat map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Result<Y>>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: SyncResult<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: SyncResult<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => any, optional: SyncResult<T>): Result<Y & {}>;\n        /**\n         * @param λ The function to flat map the value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Result<Y>>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Optional<Y>, optional: Result<T>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => AsyncResult<Y>, optional: Result<T>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => SyncResult<Y>, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Result<Y>, optional: Result<T>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(λ: (x: T) => any, optional: Result<T>): Result<Y & {}>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.flatMap as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).flatMap(...params);\n    };\n  /**\n     * Returns the result value if it is Ok, otherwise returns the error value.\n     */\n  static merge: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): Promise<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): T;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): T | Promise<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.merge as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).merge(...params);\n    };\n  /**\n     * Rejects the result if the predicate returns true.\n * Will only test the predicate if the result is Ok.\n     */\n  static reject: {\n        /**\n         * @param predicate The predicate to test\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(predicate: (x: T) => boolean): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: SyncResult<T>): Result<T>;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.reject as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).reject(...params);\n    };\n  /**\n     * Filters the result if the predicate returns true.\n * Will only test the predicate if the result is Ok.\n     */\n  static filter: {\n        /**\n         * @param predicate The predicate to test\n         */\n        <T, O extends T>(predicate: (x: T) => x is O): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<O>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<O>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, O extends T>(predicate: (x: T) => x is O, optional: AsyncResult<T>): AsyncResult<O>;\n        <T>(predicate: (x: T) => PromiseLike<boolean>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(predicate: (x: T) => boolean): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, O extends T>(predicate: (x: T) => x is O, optional: SyncResult<T>): SyncResult<O>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: SyncResult<T>): Result<T>;\n        /**\n         * @param predicate The predicate to test\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, O extends T>(predicate: (x: T) => x is O, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => PromiseLike<boolean>, optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(predicate: (x: T) => boolean | PromiseLike<boolean>, optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.filter as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).filter(...params);\n    };\n  /**\n     * Match the result type and return a value.\n     */\n  static match: {\n        /**\n         * @param callbacks The callbacks to match\n         */\n        <T, out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Promise<out_ok | out_error | out_abort>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): out_ok | out_error | out_abort;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): out_ok | out_error | out_abort | Promise<out_ok | out_error | out_abort>;\n        };\n        /**\n         * @param callbacks The callbacks to match\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>, optional: AsyncResult<T>): Promise<out_ok | out_error | out_abort>;\n        <T>(callbacks: IResultCallbacks<T, T, T, T>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(callbacks: IResultCallbacks<T, T, T, T>, optional: AsyncResult<T>): any;\n        /**\n         * @param callbacks The callbacks to match\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>, optional: SyncResult<T>): out_ok | out_error | out_abort;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(callbacks: IResultCallbacks<T, T, T, T>, optional: SyncResult<T>): any;\n        /**\n         * @param callbacks The callbacks to match\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>, optional: Result<T>): out_ok | out_error | out_abort | Promise<out_ok | out_error | out_abort>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(callbacks: IResultCallbacks<T, T, T, T>, optional: Result<T>): any;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.match as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).match(...params);\n    };\n  /**\n     * Aborts the excution if the result is an error with an error value.\n     */\n  static abortOnErrorWith: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): AsyncResult<T>;\n        <T, Y = any>(λOrValue: ((error: any) => PromiseLike<any>) | PromiseLike<any>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, Y = any>(optional: AsyncResult<T>): AsyncResult<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: ((error: any) => PromiseLike<any>) | PromiseLike<any>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T, Y = any>(λOrValue: Y | ((error: any) => any)): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: AsyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): SyncResult<T>;\n        <T, Y = any>(λOrValue: PromiseLike<any> | ((error: any) => PromiseLike<any>)): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, Y = any>(optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T, Y = any>(optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: PromiseLike<any> | ((error: any) => PromiseLike<any>), optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: SyncResult<T>): Result<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: PromiseLike<any> | ((error: any) => PromiseLike<any>), optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = any>(λOrValue: Y | ((error: any) => any), optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.abortOnErrorWith as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).abortOnErrorWith(...params);\n    };\n  /**\n     * Tap the error value if result is an error.\n     */\n  static tapError: {\n        /**\n         * @param λ The function to tap the error value with\n         */\n        <T>(λ: (x: any) => PromiseLike<void>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param λ The function to tap the error value with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<void>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(λ: (x: any) => void): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(λ: (x: any) => void | PromiseLike<void>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void | PromiseLike<void>, optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param λ The function to tap the error value with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<void>, optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void, optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void | PromiseLike<void>, optional: SyncResult<T>): Result<T>;\n        /**\n         * @param λ The function to tap the error value with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<void>, optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => void | PromiseLike<void>, optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.tapError as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).tapError(...params);\n    };\n  /**\n     * Map the error value if result is an error.\n     */\n  static mapError: {\n        /**\n         * @param λ The function to map the error value to\n         */\n        <T>(λ: (x: any) => PromiseLike<any>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): AsyncResult<T>;\n        };\n        /**\n         * @param λ The function to map the error value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<any>, optional: AsyncResult<T>): AsyncResult<T>;\n        <T>(λ: (x: any) => any): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): AsyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: AsyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): SyncResult<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: SyncResult<T>): Result<T>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): any;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <T>(optional: Result<T>): Result<T>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: AsyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: AsyncResult<T>): Result<T>;\n        /**\n         * @param λ The function to map the error value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<any>, optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: SyncResult<T>): Result<T>;\n        /**\n         * @param λ The function to map the error value to\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => PromiseLike<any>, optional: Result<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(λ: (x: any) => any, optional: Result<T>): Result<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 2) {\n        return (...subParams: any[]) => (Result.mapError as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(1, 1)[0];\n      return (instance ?? Result.Ok()).mapError(...params);\n    };\n  /**\n     * Recover the result if it is an error and the predicate returns true.\n     */\n  static recoverWhen: {\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>): {\n            /**\n             * @param λ The function to recover the result with\n             */\n            <Y = T>(λ: (x: T) => Y): {\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: AsyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: SyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: Result<T>): AsyncResult<Y>;\n            };\n            /**\n             * @param λ The function to recover the result with\n         * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<Y>;\n            <Y = T>(λ: (x: T) => PromiseLike<Y>): {\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: AsyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: SyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: Result<T>): AsyncResult<Y>;\n            };\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param λ The function to recover the result with\n         * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param λ The function to recover the result with\n         * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: Result<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<Y>;\n        };\n        /**\n         * @param predicate The predicate to test\n     * @param λ The function to recover the result with\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<Y>;\n        };\n        /**\n         * @param predicate The predicate to test\n     * @param λ The function to recover the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(predicate: (x: T) => boolean | T): {\n            <Y = T>(λ: (x: T) => PromiseLike<Y>): {\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: AsyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: SyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: Result<T>): AsyncResult<Y>;\n            };\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<Y>;\n            <Y = T>(λ: (x: T) => Y): {\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: AsyncResult<T>): AsyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: SyncResult<T>): SyncResult<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: Result<T>): any;\n            };\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: Result<T>): any;\n        };\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<Y>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): AsyncResult<Y>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): AsyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): SyncResult<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): any;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y, optional: AsyncResult<T>): AsyncResult<Y>;\n        <T, Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>): {\n            <Y = T>(λ: (x: T) => Y): {\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: AsyncResult<T>): Result<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: SyncResult<T>): Result<Y>;\n                /**\n                 * @param optional The instance parameter to use as a base to call the functions with.\n                 */\n                (optional: Result<T>): Result<Y>;\n            };\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: AsyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: SyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            <Y = T>(λ: (x: T) => Y, optional: Result<T>): Result<Y>;\n        };\n        <T, Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y): {\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: AsyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: SyncResult<T>): Result<Y>;\n            /**\n             * @param optional The instance parameter to use as a base to call the functions with.\n             */\n            (optional: Result<T>): Result<Y>;\n        };\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y, optional: AsyncResult<T>): Result<Y>;\n        /**\n         * @param predicate The predicate to test\n     * @param λ The function to recover the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y, optional: SyncResult<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>, optional: SyncResult<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y, optional: SyncResult<T>): SyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y, optional: SyncResult<T>): Result<Y>;\n        /**\n         * @param predicate The predicate to test\n     * @param λ The function to recover the result with\n     * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y, optional: Result<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>, optional: Result<T>): AsyncResult<Y>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y, optional: Result<T>): any;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T, Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y, optional: Result<T>): Result<Y>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 3) {\n        return (...subParams: any[]) => (Result.recoverWhen as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(2, 1)[0];\n      return (instance ?? Result.Ok()).recoverWhen(...params);\n    };\n  /**\n     * Aborts the excution if the result is an error.\n     */\n  static abortOnError: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): SyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): any;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.abortOnError as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).abortOnError(...params);\n    };\n  /**\n     * Converts the result to a asyncronous result.\n     */\n  static asynchronous: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): AsyncResult<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): AsyncResult<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.asynchronous as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).asynchronous(...params);\n    };\n  /**\n     * Converts the result to a promise.\n     */\n  static toPromise: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): Promise<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): Promise<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): Promise<T>;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.toPromise as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).toPromise(...params);\n    };\n  /**\n     * Converts the result to an optional object.\n     */\n  static toOptional: {\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: AsyncResult<T>): Promise<Optional<T>>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: SyncResult<T>): Optional<T>;\n        /**\n         * @param optional The instance parameter to use as a base to call the functions with.\n         */\n        <T>(optional: Result<T>): any;\n    } = <T>(...params: any[]): any => {\n      if (params.length < 1) {\n        return (...subParams: any[]) => (Result.toOptional as any)(...[...params, ...subParams]);\n      }\n      const instance = params.splice(0, 1)[0];\n      return (instance ?? Result.Ok()).toOptional(...params);\n    };\n    /**\n       * Returns the value of the result.\n       * If the result is not Ok, it will throw an error.\n       * @throws Error if the result is not Ok\n       * @returns The value of the result\n       * @example\n       * const result = Result.Ok(1);\n       * const value = result.get(); // 1\n       */\n    abstract get(): T | Promise<T>;\n    /**\n       * Returns the value of the result.\n       * If the result is not Ok, it will return the value provided.\n       * @param value The value to return if the result is not Ok\n       * @returns The value of the result or the provided value\n       * @example\n       * const result = Result.Ok(1);\n       * const value = result.getOrElse(2); // 1\n       *\n       * const result = Result.Error(1);\n       * const value = result.getOrElse(2); // 2\n       */\n    abstract getOrElse<Y = T>(value?: Y): T | Y | Promise<T> | Promise<Y>;\n    /**\n       * Recovers from an error if an error occurs.\n       * @param λ The function to recover with\n       * @returns A new result with the recovered value\n       * @example\n       * const result = Result.Error(1);\n       * const recovered = result.recover(() => 5); // Result.Ok(5)\n       *\n       * const result = Result.Ok(1);\n       * const recovered = result.recover(() => 5); // Result.Ok(1)\n       */\n    abstract recover<R = T>(λ: (x: any) => PromiseLike<R>): AsyncResult<T | R>;\n    abstract recover<R = T>(λ: (x: any) => R): SyncResult<T | R> | AsyncResult<T | R>;\n    abstract recover<R = T>(λ: (x: any) => R): Result<T | R>;\n    /**\n       * Replace the value of the result.\n       * Will only replace the value if the result is Ok.\n       * @param value The value to replace the result with\n       * @returns A new result with the replaced value\n       * @example\n       * const result = Result.Ok(1);\n       * const replaced = result.replace(5); // Result.Ok(5)\n       *\n       * const result = Result.Error(1);\n       * const replaced = result.replace(5); // Result.Error(1)\n       */\n    abstract replace<Y = T>(value: PromiseLike<Y>): AsyncResult<Y>;\n    abstract replace<Y = T>(value: Y): SyncResult<Y> | AsyncResult<Y>;\n    abstract replace<Y = T>(value: Y | PromiseLike<Y>): Result<Y>;\n    /**\n       * Returns the wrapped property value if the result contains an object.\n       * Will return an Error result if the property was not found.\n       * @param propertyName The name of the property to get\n       * @returns A new result with the property value\n       * @example\n       * const result = Result.Ok({ name: \"John\" });\n       * const name = result.expectProperty(\"name\"); // Result.Ok(\"John\")\n       *\n       * const result = Result.Ok({ name: \"John\" });\n       * const name = result.expectProperty(\"age\"); // Result.Error()\n       */\n    abstract expectProperty(propertyName: IfAny<T, any, never>): SyncResult<any> | AsyncResult<any>;\n    abstract expectProperty(propertyName: IfAny<T, any, never>): Result<any>;\n    abstract expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): SyncResult<IfAnyOrUnknown<V, any, V & {}>> | AsyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n    abstract expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): Result<IfAnyOrUnknown<V, any, V & {}>>;\n    /**\n       * Returns the wrapped property value if the result contains an object.\n       * Will always return an Ok result even if the property was not found.\n       * @param propertyName The name of the property to get\n       * @returns A new result with the property value\n       * @example\n       * const result = Result.Ok({ name: \"John\" });\n       * const name = result.property(\"name\"); // Result.Ok(\"John\")\n       *\n       * const result = Result.Ok({ name: \"John\" });\n       * const name = result.property(\"age\"); // Result.Ok(undefined)\n       */\n    abstract property(propertyName: IfAny<T, any, never>): SyncResult<any> | AsyncResult<any>;\n    abstract property(propertyName: IfAny<T, any, never>): Result<any>;\n    abstract property<Y extends keyof T>(propertyName: Y): SyncResult<Y extends keyof T ? T[Y] : any> | AsyncResult<Y extends keyof T ? T[Y] : any>;\n    abstract property<Y extends keyof T>(propertyName: Y): Result<Y extends keyof T ? T[Y] : any>;\n    /**\n       * Tap into the result and perform an action.\n       * Will only perform the action if the result is Ok.\n       * @param λ The action to perform\n       * @returns The result\n       * @example\n       * const result = Result.Ok(1);\n       * const tapped = result.tap(x => console.log(x)); // Logs: \"1\"\n       *\n       * const result = Result.Error(1);\n       * const tapped = result.tap(x => console.log(x)); // No logs!\n       */\n    abstract tap(λ: (x: T) => PromiseLike<void>): AsyncResult<T>;\n    abstract tap(λ: (x: T) => void): SyncResult<T> | AsyncResult<T>;\n    abstract tap(λ: (x: T) => void | PromiseLike<void>): Result<T>;\n    /**\n       * Test if the result satisfies a predicate.\n       * Will only test the predicate if the result is Ok.\n       * @param predicate The predicate to test\n       * @returns A boolean result\n       * @example\n       * const result = Result.Ok(1);\n       * const satisfied = result.satisfies(x => x === 1); // true\n       *\n       * const result = Result.Error(1);\n       * const satisfied = result.satisfies(x => x === 1); // false\n       */\n    abstract satisfies(predicate: (x: T) => PromiseLike<T | boolean>): Promise<boolean>;\n    abstract satisfies(predicate: (x: T) => T | boolean): boolean | Promise<boolean>;\n    /**\n       * Test if the result value equals another value.\n       * Will only test the equality if the result is Ok.\n       * @param value The value to test equality with\n       * @returns A boolean result\n       * @example\n       * const result = Result.Ok(1);\n       * const satisfied = result.valueEquals(1); // true\n       *\n       * const result = Result.Error(1);\n       * const satisfied = result.valueEquals(1); // false\n       */\n    abstract valueEquals(value: T): boolean | Promise<boolean>;\n    /**\n       * Map the result value.\n       * Will only map the value if the result is Ok.\n       * Will always return an Ok result even if the passed value is undefined.\n       * @param λ The function to map the value to\n       * @returns A new result with the mapped value\n       * @see {@link transform} Alias\n       * @example\n       * const result = Result.Ok(1);\n       * const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n       *\n       * const result = Result.Ok(1);\n       * const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n       *\n       * const result = Result.Error(1);\n       * const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n       */\n    abstract map<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract map<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y>> | AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract map<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    /**\n       * Map the result value.\n       * Will only map the value if the result is Ok.\n       * Will always return an Ok result even if the passed value is undefined.\n       * @param λ The function to map the value to\n       * @returns A new result with the mapped value\n       * @see {@link map} Alias\n       * @example\n       * const result = Result.Ok(1);\n       * const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n       *\n       * const result = Result.Ok(1);\n       * const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n       *\n       * const result = Result.Error(1);\n       * const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n       */\n    abstract transform<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract transform<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y>> | AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract transform<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    /**\n     * Map the result value.\n     * Will only map the value if the result is Ok.\n     * Will return an Error result if the passed value is undefined.\n     * @param λ The function to map the value to\n     * @returns A new result with the mapped value\n     * @example\n     * const result = Result.Ok(1);\n     * const mapped = result.expectMap((x) => ({age: x})); // Result.Ok({age: 1})\n     *\n     * const result = Result.Ok(1);\n     * const mapped = result.expectMap((x) => undefined); // Result.Error()\n     *\n     * const result = Result.Error(1);\n     * const mapped = result.expectMap((x) => ({age: x})); // Result.Error(1)\n     */\n    abstract expectMap<Y = T>(λ: (x: T) => PromiseLike<Optional<T>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => SyncResult<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>> | AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    /**\n       * Map the result value and flatten the result.\n       * Will only map the value if the result is Ok.\n       * @param λ The function to flat map the value to\n       * @returns A new result with the flat mapped value\n       * @example\n       * const result = Result.Ok(1);\n       * const mapped = result.flatMap((x) => 5)); // Result.Ok(5)\n       *\n       * const result = Result.Error(1);\n       * const mapped = result.flatMap((x) => 5)); // Result.Error(1)\n       *\n       * const result = Result.Ok(1);\n       * const mapped = result.flatMap((x) => Result.Ok(5)); // Result.Ok(5)\n       */\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Result<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => SyncResult<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>> | AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>> | AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Optional<IfAnyOrUnknown<Y, any, Y>>> | PromiseLike<Result<IfAnyOrUnknown<Y, any, Y>>> | PromiseLike<IfAnyOrUnknown<Y, any, Y>> | Optional<IfAnyOrUnknown<Y, any, Y>> | Result<IfAnyOrUnknown<Y, any, Y>> | IfAnyOrUnknown<Y, any, Y>): Result<Y & {}>;\n    /**\n       * Returns the result value if it is Ok, otherwise returns the error value.\n       * @returns The result value or the error value\n       * @example\n       * const result = Result.Ok(5);\n       * const value = result.merge(); // 5\n       *\n       * const result = Result.Error(10);\n       * const value = result.merge(); // 10\n       */\n    abstract merge(): T | Promise<T>;\n    /**\n       * Rejects the result if the predicate returns true.\n       * Will only test the predicate if the result is Ok.\n       * @param predicate The predicate to test\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const rejected = result.reject(x => x === 1); // Result.Error()\n       */\n    abstract reject(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n    abstract reject(predicate: (x: T) => boolean): SyncResult<T> | AsyncResult<T>;\n    abstract reject(predicate: (x: T) => PromiseLike<boolean> | boolean): Result<T>;\n    /**\n       * Filters the result if the predicate returns true.\n       * Will only test the predicate if the result is Ok.\n       * @param predicate The predicate to test\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const filtered = result.filter(x => x === 1); // Result.Ok(1)\n       *\n       * const result = Result.Ok(1);\n       * const filtered = result.filter(x => x === 2); // Result.Error(2)\n       */\n    abstract filter<O extends T>(predicate: (x: T) => x is O): SyncResult<O> | AsyncResult<O>;\n    abstract filter(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n    abstract filter(predicate: (x: T) => boolean): SyncResult<T> | AsyncResult<T>;\n    abstract filter(predicate: (x: T) => PromiseLike<boolean> | boolean): Result<T>;\n    /**\n       * Match the result type and return a value.\n       * @param callbacks The callbacks to match\n       * @returns The matched value\n       * @example\n       * const result = Result.Ok(1);\n       * const value = result.match({\n       *  Ok: (x) => 10,\n       *  Error: (x) => 15\n       * }); // 10\n       *\n       * const result = Result.Error(1);\n       * const value = result.match({\n       *  Ok: (x) => 10,\n       *  Error: (x) => 15\n       * }); // 15\n       */\n    abstract match<out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>): out_ok | out_error | out_abort | Promise<out_ok | out_error | out_abort>;\n    abstract match(callbacks: IResultCallbacks<T>): any;\n    /**\n       * Aborts the excution if the result is an error with an error value.\n       * @param λOrValue The function or value to set as error message if the result is an error\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const aborted = result.abortOnError(); // Result.Ok(1)\n       *\n       * const result = Result.Error(1);\n       * const aborted = result.abortOnError(); // Result.Aborted()\n       *\n       * const result = Result.Error(1);\n       * const aborted = result.abortOnError('Error'); // Result.Aborted('Error')\n       */\n    abstract abortOnErrorWith(): SyncResult<T> | AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: ((error: any) => PromiseLike<any>) | PromiseLike<any>): AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: ((error: any) => any) | Y): SyncResult<T> | AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: ((error: any) => any) | Y): Result<T>;\n    /**\n       * Tap the error value if result is an error.\n       * @param λ The function to tap the error value with\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const tapped = result.tapError(x => console.log(x)); // No logs!\n       *\n       * const result = Result.Error(1);\n       * const tapped = result.tapError(x => console.log(x)); // Logs: \"1\"\n       */\n    abstract tapError(λ: (x: any) => PromiseLike<void>): AsyncResult<T>;\n    abstract tapError(λ: (x: any) => void): SyncResult<T> | AsyncResult<T>;\n    abstract tapError(λ: (x: any) => PromiseLike<void> | void): Result<T>;\n    /**\n       * Map the error value if result is an error.\n       * @param λ The function to map the error value to\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const mapped = result.mapError(x => 10); // Result.Ok(1)\n       *\n       * const result = Result.Error(1);\n       * const mapped = result.mapError(x => 10); // Result.Error(10)\n       */\n    abstract mapError(λ: (x: any) => PromiseLike<any>): AsyncResult<T>;\n    abstract mapError(λ: (x: any) => any): SyncResult<T> | AsyncResult<T>;\n    abstract mapError(λ: (x: any) => PromiseLike<any> | any): Result<T>;\n    /**\n       * Recover the result if it is an error and the predicate returns true.\n       * @param predicate The predicate to test\n       * @param λ The function to recover the result with\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(1)\n       *\n       * const result = Result.Error(1);\n       * const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(10)\n       *\n       * const result = Result.Error(1);\n       * const recovered = result.recoverWhen(x => false, x => 10); // Result.Error(1)\n       */\n    abstract recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<T | boolean>, λ: (x: T) => Y): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => T | boolean, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<T | boolean>, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => T | boolean, λ: (x: T) => Y): SyncResult<Y> | AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => T | boolean | PromiseLike<T | boolean>, λ: (x: T) => Y): Result<Y>;\n    /**\n       * Aborts the excution if the result is an error.\n       * @returns A new result\n       * @example\n       * const result = Result.Ok(1);\n       * const aborted = result.abortOnError(); // Result.Ok(1)\n       *\n       * const result = Result.Error(1);\n       * const aborted = result.abortOnError(); // Result.Aborted()\n       */\n    abstract abortOnError(): SyncResult<T> | AsyncResult<T>;\n    /**\n       * Converts the result to a asyncronous result.\n       * @returns A new async result\n       * @example\n       * const result = Result.Ok(1);\n       * const async = result.asynchronous(); // Result.Pending(Result.Ok(1))\n       *\n       * const result = Result.Error(1);\n       * const async = result.asynchronous(); // Result.Pending(Result.Error(1))\n       */\n    abstract asynchronous(): AsyncResult<T>;\n    /**\n       * Converts the result to a promise.\n       * @returns A promise\n       * @example\n       * const result = Result.Ok(1);\n       * const promise = result.promise(); // Promise<1>\n       */\n    abstract toPromise(): Promise<T>;\n    /**\n       * Converts the result to an optional object.\n       * @returns An optional\n       * @example\n       * const result = Result.Ok(1);\n       * const optional = result.toOptional(); // Optional.Some(1)\n       *\n       * const result = Result.Error(1);\n       * const optional = result.toOptional(); // Optional.None\n       */\n    abstract toOptional(): Optional<T> | Promise<Optional<T>>;\n}\n","// ========================================================\n// This file is generated by syncResult.gen.ts\n// Do not edit this file directly\n// ========================================================\n/* eslint-disable @typescript-eslint/ban-types */\nimport { IResultCallbacks } from '@src/result.types';\nimport { AsyncResult } from './asyncResult.generated';\nimport { Result } from './result.generated';\nimport { Optional } from './optional.generated';\nimport returnThis from '@utils/return-this';\nimport { IfAnyOrUnknown, IfAny } from '@utils/types';\n/**\n * A result that is not awaitable.\n * Contrary to the AsyncResult, this result object does not contain\n * a promise that can be awaited.\n * @template T The type of the value of the result\n * @see {@link AsyncResult} for an awaitable result\n * @see {@link Result} for a result that can be both asynchronous and synchronous\n * @example\n * const result = Result\n *  .expect('hello world');\n *\n * const value = result.get(); // 'hello world'\n */\nexport abstract class SyncResult<T = any> extends Result<T> {\n  /**\n* Returns the value of the result.\n* If the result is not Ok, it will throw an error.\n* @throws Error if the result is not Ok\n* @returns The value of the result\n* @example\n* const result = Result.Ok(1);\n* const value = result.get(); // 1\n*/\n  get(): T;\n  get(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Returns the value of the result.\n* If the result is not Ok, it will return the value provided.\n* @param value The value to return if the result is not Ok\n* @returns The value of the result or the provided value\n* @example\n* const result = Result.Ok(1);\n* const value = result.getOrElse(2); // 1\n*\n* const result = Result.Error(1);\n* const value = result.getOrElse(2); // 2\n*/\n  getOrElse<Y = T>(value?: Y): T | Y;\n  getOrElse(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Recovers from an error if an error occurs.\n* @param λ The function to recover with\n* @returns A new result with the recovered value\n* @example\n* const result = Result.Error(1);\n* const recovered = result.recover(() => 5); // Result.Ok(5)\n*\n* const result = Result.Ok(1);\n* const recovered = result.recover(() => 5); // Result.Ok(1)\n*/\n  recover<R = T>(λ: (x: any) => PromiseLike<R>): AsyncResult<T | R>;\n  recover<R = T>(λ: (x: any) => R): SyncResult<T | R>;\n  recover<R = T>(λ: (x: any) => R): Result<T | R>;\n  recover(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Replace the value of the result.\n* Will only replace the value if the result is Ok.\n* @param value The value to replace the result with\n* @returns A new result with the replaced value\n* @example\n* const result = Result.Ok(1);\n* const replaced = result.replace(5); // Result.Ok(5)\n*\n* const result = Result.Error(1);\n* const replaced = result.replace(5); // Result.Error(1)\n*/\n  replace<Y = T>(value: PromiseLike<Y>): AsyncResult<Y>;\n  replace<Y = T>(value: Y): SyncResult<Y>;\n  replace<Y = T>(value: Y | PromiseLike<Y>): Result<Y>;\n  replace(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Returns the wrapped property value if the result contains an object.\n* Will return an Error result if the property was not found.\n* @param propertyName The name of the property to get\n* @returns A new result with the property value\n* @example\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.expectProperty(\"name\"); // Result.Ok(\"John\")\n*\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.expectProperty(\"age\"); // Result.Error()\n*/\n  expectProperty(propertyName: IfAny<T, any, never>): SyncResult<any>;\n  expectProperty(propertyName: IfAny<T, any, never>): Result<any>;\n  expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): SyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n  expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): Result<IfAnyOrUnknown<V, any, V & {}>>;\n  expectProperty(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Returns the wrapped property value if the result contains an object.\n* Will always return an Ok result even if the property was not found.\n* @param propertyName The name of the property to get\n* @returns A new result with the property value\n* @example\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.property(\"name\"); // Result.Ok(\"John\")\n*\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.property(\"age\"); // Result.Ok(undefined)\n*/\n  property(propertyName: IfAny<T, any, never>): SyncResult<any>;\n  property(propertyName: IfAny<T, any, never>): Result<any>;\n  property<Y extends keyof T>(propertyName: Y): SyncResult<Y extends keyof T ? T[Y] : any>;\n  property<Y extends keyof T>(propertyName: Y): Result<Y extends keyof T ? T[Y] : any>;\n  property(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Tap into the result and perform an action.\n* Will only perform the action if the result is Ok.\n* @param λ The action to perform\n* @returns The result\n* @example\n* const result = Result.Ok(1);\n* const tapped = result.tap(x => console.log(x)); // Logs: \"1\"\n*\n* const result = Result.Error(1);\n* const tapped = result.tap(x => console.log(x)); // No logs!\n*/\n  tap(λ: (x: T) => PromiseLike<void>): AsyncResult<T>;\n  tap(λ: (x: T) => void): SyncResult<T>;\n  tap(λ: (x: T) => void | PromiseLike<void>): Result<T>;\n  tap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Test if the result satisfies a predicate.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A boolean result\n* @example\n* const result = Result.Ok(1);\n* const satisfied = result.satisfies(x => x === 1); // true\n*\n* const result = Result.Error(1);\n* const satisfied = result.satisfies(x => x === 1); // false\n*/\n  satisfies(predicate: (x: T) => PromiseLike<boolean | T>): Promise<boolean>;\n  satisfies(predicate: (x: T) => boolean | T): boolean;\n  satisfies(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Test if the result value equals another value.\n* Will only test the equality if the result is Ok.\n* @param value The value to test equality with\n* @returns A boolean result\n* @example\n* const result = Result.Ok(1);\n* const satisfied = result.valueEquals(1); // true\n*\n* const result = Result.Error(1);\n* const satisfied = result.valueEquals(1); // false\n*/\n  valueEquals(value: T): boolean;\n  valueEquals(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will always return an Ok result even if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @see {@link transform} Alias\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n*\n* const result = Result.Error(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n*/\n  map<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n  map<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n  map<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n  map(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will always return an Ok result even if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @see {@link map} Alias\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n*\n* const result = Result.Error(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n*/\n  transform<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n  transform<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y>>;\n  transform<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n  transform(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will return an Error result if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.expectMap((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.expectMap((x) => undefined); // Result.Error()\n*\n* const result = Result.Error(1);\n* const mapped = result.expectMap((x) => ({age: x})); // Result.Error(1)\n*/\n  expectMap<Y = T>(λ: (x: T) => PromiseLike<Optional<T>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => SyncResult<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n  expectMap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Map the result value and flatten the result.\n* Will only map the value if the result is Ok.\n* @param λ The function to flat map the value to\n* @returns A new result with the flat mapped value\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.flatMap((x) => 5)); // Result.Ok(5)\n*\n* const result = Result.Error(1);\n* const mapped = result.flatMap((x) => 5)); // Result.Error(1)\n*\n* const result = Result.Ok(1);\n* const mapped = result.flatMap((x) => Result.Ok(5)); // Result.Ok(5)\n*/\n  flatMap<Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => PromiseLike<Result<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => SyncResult<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => Y): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n  flatMap<Y = T>(λ: (x: T) => any): Result<Y & {}>;\n  flatMap(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Returns the result value if it is Ok, otherwise returns the error value.\n* @returns The result value or the error value\n* @example\n* const result = Result.Ok(5);\n* const value = result.merge(); // 5\n*\n* const result = Result.Error(10);\n* const value = result.merge(); // 10\n*/\n  merge(): T;\n  merge(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Rejects the result if the predicate returns true.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const rejected = result.reject(x => x === 1); // Result.Error()\n*/\n  reject(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n  reject(predicate: (x: T) => boolean): SyncResult<T>;\n  reject(predicate: (x: T) => boolean | PromiseLike<boolean>): Result<T>;\n  reject(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Filters the result if the predicate returns true.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const filtered = result.filter(x => x === 1); // Result.Ok(1)\n*\n* const result = Result.Ok(1);\n* const filtered = result.filter(x => x === 2); // Result.Error(2)\n*/\n  filter<O extends T>(predicate: (x: T) => x is O): SyncResult<O>;\n  filter(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n  filter(predicate: (x: T) => boolean): SyncResult<T>;\n  filter(predicate: (x: T) => boolean | PromiseLike<boolean>): Result<T>;\n  filter(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Match the result type and return a value.\n* @param callbacks The callbacks to match\n* @returns The matched value\n* @example\n* const result = Result.Ok(1);\n* const value = result.match({\n*  Ok: (x) => 10,\n*  Error: (x) => 15\n* }); // 10\n*\n* const result = Result.Error(1);\n* const value = result.match({\n*  Ok: (x) => 10,\n*  Error: (x) => 15\n* }); // 15\n*/\n  match<out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>): out_ok | out_error | out_abort;\n  match(callbacks: IResultCallbacks<T, T, T, T>): any;\n  match(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Aborts the excution if the result is an error with an error value.\n* @param λOrValue The function or value to set as error message if the result is an error\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const aborted = result.abortOnError(); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError(); // Result.Aborted()\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError('Error'); // Result.Aborted('Error')\n*/\n  abortOnErrorWith(): SyncResult<T>;\n  abortOnErrorWith<Y = any>(λOrValue: ((error: any) => PromiseLike<any>) | PromiseLike<any>): AsyncResult<T>;\n  abortOnErrorWith<Y = any>(λOrValue: Y | ((error: any) => any)): SyncResult<T>;\n  abortOnErrorWith<Y = any>(λOrValue: Y | ((error: any) => any)): Result<T>;\n  abortOnErrorWith(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Tap the error value if result is an error.\n* @param λ The function to tap the error value with\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const tapped = result.tapError(x => console.log(x)); // No logs!\n*\n* const result = Result.Error(1);\n* const tapped = result.tapError(x => console.log(x)); // Logs: \"1\"\n*/\n  tapError(λ: (x: any) => PromiseLike<void>): AsyncResult<T>;\n  tapError(λ: (x: any) => void): SyncResult<T>;\n  tapError(λ: (x: any) => void | PromiseLike<void>): Result<T>;\n  tapError(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Map the error value if result is an error.\n* @param λ The function to map the error value to\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.mapError(x => 10); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const mapped = result.mapError(x => 10); // Result.Error(10)\n*/\n  mapError(λ: (x: any) => PromiseLike<any>): AsyncResult<T>;\n  mapError(λ: (x: any) => any): SyncResult<T>;\n  mapError(λ: (x: any) => any): Result<T>;\n  mapError(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Recover the result if it is an error and the predicate returns true.\n* @param predicate The predicate to test\n* @param λ The function to recover the result with\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(10)\n*\n* const result = Result.Error(1);\n* const recovered = result.recoverWhen(x => false, x => 10); // Result.Error(1)\n*/\n  recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y): AsyncResult<Y>;\n  recoverWhen<Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n  recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n  recoverWhen<Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y): SyncResult<Y>;\n  recoverWhen<Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y): Result<Y>;\n  recoverWhen(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Aborts the excution if the result is an error.\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const aborted = result.abortOnError(); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError(); // Result.Aborted()\n*/\n  abortOnError(): SyncResult<T>;\n  abortOnError(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Converts the result to a asyncronous result.\n* @returns A new async result\n* @example\n* const result = Result.Ok(1);\n* const async = result.asynchronous(); // Result.Pending(Result.Ok(1))\n*\n* const result = Result.Error(1);\n* const async = result.asynchronous(); // Result.Pending(Result.Error(1))\n*/\n  asynchronous(): AsyncResult<T>;\n  asynchronous(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Converts the result to a promise.\n* @returns A promise\n* @example\n* const result = Result.Ok(1);\n* const promise = result.promise(); // Promise<1>\n*/\n  toPromise(): Promise<T>;\n  toPromise(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n  /**\n* Converts the result to an optional object.\n* @returns An optional\n* @example\n* const result = Result.Ok(1);\n* const optional = result.toOptional(); // Optional.Some(1)\n*\n* const result = Result.Error(1);\n* const optional = result.toOptional(); // Optional.None\n*/\n  toOptional(): Optional<T>;\n  toOptional(...args: any[]): any {\n    return returnThis.any.call(this, ...args);\n  }\n}\n","import throwArgument from '@utils/throw-argument';\n\nimport { Optional } from '@optional/index';\n\nimport { IResultCallbacks } from '@src/result.types';\nimport { Result } from '@generated/result.generated';\nimport { SyncResult } from '@generated/syncResult.generated';\nimport { TransformResult } from './result.utils';\nimport { constant } from '@utils/utils';\n\nexport class AbortedClass extends SyncResult<any> {\n  isError = true as const;\n  isAborted = true as const;\n\n  error: any;\n\n  constructor(error: any) {\n    super();\n    this.error = error;\n  }\n\n  tapError(λ: any): any {\n    return TransformResult(() => λ(this.error), constant(this));\n  }\n\n  get(): any {\n    throw this.error;\n  }\n\n  getOrElse(value: any): any {\n    return value;\n  }\n\n  satisfies(): any {\n    return false;\n  }\n\n  valueEquals(): boolean {\n    return false;\n  }\n\n  merge(): any {\n    return this.error;\n  }\n\n  match(callbacks: IResultCallbacks<any, any>): any {\n    return (callbacks.Aborted || throwArgument)(this.error);\n  }\n\n  asynchronous(): any {\n    return Result.Pending(Promise.resolve(this));\n  }\n\n  toPromise(): Promise<any> {\n    return Promise.reject(this.error);\n  }\n\n  toOptional(): Optional<any> {\n    return Optional.None();\n  }\n}\n","import throwArgument from '@utils/throw-argument';\nimport { constant } from '@utils/utils';\n\nimport { Optional } from '@optional/index';\n\nimport { IResultCallbacks } from '@src/result.types';\nimport { Result } from '@generated/result.generated';\nimport { SyncResult } from '@generated/syncResult.generated';\n\nimport { TransformResult } from './result.utils';\n\nexport class ErrorClass extends SyncResult<any> {\n  isError = true as const;\n\n  error: any;\n\n  constructor(error: any) {\n    super();\n    this.error = error;\n  }\n\n  get(): any {\n    throw this.error;\n  }\n\n  getOrElse(value: any): any {\n    return value;\n  }\n\n  recover(λ: any): any {\n    return TransformResult(() => λ(this.error), Result.Ok);\n  }\n\n  recoverWhen(predicate: any, λ: any): any {\n    return Result.Ok(this.error)\n      .filter(predicate)\n      .mapError(constant(this.error))\n      .map(λ);\n  }\n\n  satisfies(): any {\n    return false;\n  }\n\n  valueEquals(): boolean {\n    return false;\n  }\n\n  merge(): any {\n    return this.error;\n  }\n\n  match(callbacks: IResultCallbacks<any, any>): any {\n    return (callbacks.Error || throwArgument)(this.error);\n  }\n\n  tapError(λ: (x: any) => void): any {\n    return TransformResult(() => λ(this.error), constant(this));\n  }\n\n  mapError(λ: (x: any) => any): any {\n    return TransformResult(() => λ(this.error), Result.Error);\n  }\n\n  abortOnError(): any {\n    return Result.Aborted(this.error);\n  }\n\n  abortOnErrorWith(λOrValue?: any): any {\n    return TransformResult(() => {\n      if (typeof λOrValue === 'function') {\n        return (<(error: any) => any>λOrValue)(this.error);\n      }\n\n      return λOrValue;\n    }, Result.Aborted);\n  }\n\n  asynchronous(): any {\n    return Result.Pending(Promise.resolve(this));\n  }\n\n  toPromise(): Promise<any> {\n    return Promise.reject(this.error);\n  }\n\n  toOptional(): Optional<any> {\n    return Optional.None();\n  }\n}\n","import { identity, constant } from '@utils/utils';\n\nimport { Optional } from '@optional/index';\n\nimport { IResultCallbacks } from '@src/result.types';\nimport { Result } from '@generated/result.generated';\nimport { SyncResult } from '@generated/syncResult.generated';\n\nimport { expect, TransformResult } from './result.utils';\n\nexport class OkClass<T> extends SyncResult<T> {\n  isOk = true as const;\n\n  value: T;\n\n  constructor(someValue?: T) {\n    super();\n    this.value = someValue!;\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  getOrElse<Y>(): T | Y {\n    return this.value;\n  }\n\n  replace(value: any): any {\n    return TransformResult(constant(value), Result.Ok);\n  }\n\n  expectProperty(propertyName: string): any {\n    return expect((this.value as any)[propertyName]);\n  }\n\n  property(propertyName: string): any {\n    return Result.Ok((this.value as any)[propertyName]);\n  }\n\n  tap(λ: (x: T) => void): any {\n    return TransformResult(() => λ(this.value), constant(this));\n  }\n\n  satisfies(predicate: (x: T) => any): any {\n    return TransformResult(() => predicate(this.value), Boolean);\n  }\n\n  valueEquals(value: T): boolean {\n    return this.value === value;\n  }\n\n  map(λ: (x: T) => any): any {\n    return TransformResult(() => λ(this.value), Result.Ok);\n  }\n\n  transform(λ: (x: T) => any): any {\n    return this.map(λ);\n  }\n\n  expectMap(λ: (x: T) => any): any {\n    return expect(λ(this.value));\n  }\n\n  flatMap(λ: (x: T) => any): any {\n    return TransformResult(() => λ(this.value), expect);\n  }\n\n  merge(): T {\n    return this.value;\n  }\n\n  reject(predicate: (x: T) => any): any {\n    return TransformResult(\n      () => predicate(this.value),\n      (isTruthy) => (isTruthy\n        ? Result.Error()\n        : Result.Ok(this.value)\n      )\n    );\n  }\n\n  filter(predicate: (x: T) => any): any {\n    return TransformResult(\n      () => predicate(this.value),\n      (isTruthy) => (isTruthy\n        ? Result.Ok(this.value)\n        : Result.Error()\n      )\n    );\n  }\n\n  match(callbacks: IResultCallbacks<any, any>): any {\n    return (callbacks.Ok || identity)(this.value);\n  }\n\n  asynchronous(): any {\n    return Result.Pending(Promise.resolve(this));\n  }\n\n  toPromise(): Promise<T> {\n    return Promise.resolve(this.value);\n  }\n\n  toOptional(): Optional<T> {\n    return Optional.Some(this.value);\n  }\n}\n","// ========================================================\n// This file is generated by asyncResult.gen.ts\n// Do not edit this file directly\n// ========================================================\n/* eslint-disable @typescript-eslint/ban-types */\nimport { IResultCallbacks } from '@src/result.types';\nimport { IfAny, IfAnyOrUnknown } from '@utils/types';\nimport { Optional } from './optional.generated';\nimport { Result } from './result.generated';\nimport { SyncResult } from './syncResult.generated';\n/**\n * A result that can be awaited.\n * Contrary to the SyncResult, this result object contains\n * a promise that can be awaited. When used, the entire current\n * chain of result will be converted to AsyncResult.\n * @template T The type of the value of the result\n * @see {@link SyncResult} for a synchronous version of this class\n * @see {@link Result} for a result that can be both asynchronous and synchronous\n * @example\n * const result = Result\n *  .expect(Promise.resolve('hello world'))\n *  .toPromise();\n *\n * const value = await result; // 'hello world'\n */\nexport abstract class AsyncResult<T = any> extends Result<T> {\n    /**\n* Returns the value of the result.\n* If the result is not Ok, it will throw an error.\n* @throws Error if the result is not Ok\n* @returns The value of the result\n* @example\n* const result = Result.Ok(1);\n* const value = result.get(); // 1\n*/\n    abstract get(): Promise<T>;\n    /**\n* Returns the value of the result.\n* If the result is not Ok, it will return the value provided.\n* @param value The value to return if the result is not Ok\n* @returns The value of the result or the provided value\n* @example\n* const result = Result.Ok(1);\n* const value = result.getOrElse(2); // 1\n*\n* const result = Result.Error(1);\n* const value = result.getOrElse(2); // 2\n*/\n    abstract getOrElse<Y = T>(value?: Y): Promise<T> | Promise<Y>;\n    /**\n* Recovers from an error if an error occurs.\n* @param λ The function to recover with\n* @returns A new result with the recovered value\n* @example\n* const result = Result.Error(1);\n* const recovered = result.recover(() => 5); // Result.Ok(5)\n*\n* const result = Result.Ok(1);\n* const recovered = result.recover(() => 5); // Result.Ok(1)\n*/\n    abstract recover<R = T>(λ: (x: any) => PromiseLike<R>): AsyncResult<T | R>;\n    abstract recover<R = T>(λ: (x: any) => R): AsyncResult<T | R>;\n    abstract recover<R = T>(λ: (x: any) => R): Result<T | R>;\n    /**\n* Replace the value of the result.\n* Will only replace the value if the result is Ok.\n* @param value The value to replace the result with\n* @returns A new result with the replaced value\n* @example\n* const result = Result.Ok(1);\n* const replaced = result.replace(5); // Result.Ok(5)\n*\n* const result = Result.Error(1);\n* const replaced = result.replace(5); // Result.Error(1)\n*/\n    abstract replace<Y = T>(value: PromiseLike<Y>): AsyncResult<Y>;\n    abstract replace<Y = T>(value: Y): AsyncResult<Y>;\n    abstract replace<Y = T>(value: Y | PromiseLike<Y>): Result<Y>;\n    /**\n* Returns the wrapped property value if the result contains an object.\n* Will return an Error result if the property was not found.\n* @param propertyName The name of the property to get\n* @returns A new result with the property value\n* @example\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.expectProperty(\"name\"); // Result.Ok(\"John\")\n*\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.expectProperty(\"age\"); // Result.Error()\n*/\n    abstract expectProperty(propertyName: IfAny<T, any, never>): AsyncResult<any>;\n    abstract expectProperty(propertyName: IfAny<T, any, never>): Result<any>;\n    abstract expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): AsyncResult<IfAnyOrUnknown<V, any, V & {}>>;\n    abstract expectProperty<Y extends keyof T, U = Y extends keyof T ? T[Y] : any, V = U extends Optional<infer X> ? X : U>(propertyName: Y): Result<IfAnyOrUnknown<V, any, V & {}>>;\n    /**\n* Returns the wrapped property value if the result contains an object.\n* Will always return an Ok result even if the property was not found.\n* @param propertyName The name of the property to get\n* @returns A new result with the property value\n* @example\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.property(\"name\"); // Result.Ok(\"John\")\n*\n* const result = Result.Ok({ name: \"John\" });\n* const name = result.property(\"age\"); // Result.Ok(undefined)\n*/\n    abstract property(propertyName: IfAny<T, any, never>): AsyncResult<any>;\n    abstract property(propertyName: IfAny<T, any, never>): Result<any>;\n    abstract property<Y extends keyof T>(propertyName: Y): AsyncResult<Y extends keyof T ? T[Y] : any>;\n    abstract property<Y extends keyof T>(propertyName: Y): Result<Y extends keyof T ? T[Y] : any>;\n    /**\n* Tap into the result and perform an action.\n* Will only perform the action if the result is Ok.\n* @param λ The action to perform\n* @returns The result\n* @example\n* const result = Result.Ok(1);\n* const tapped = result.tap(x => console.log(x)); // Logs: \"1\"\n*\n* const result = Result.Error(1);\n* const tapped = result.tap(x => console.log(x)); // No logs!\n*/\n    abstract tap(λ: (x: T) => PromiseLike<void>): AsyncResult<T>;\n    abstract tap(λ: (x: T) => void): AsyncResult<T>;\n    abstract tap(λ: (x: T) => void | PromiseLike<void>): Result<T>;\n    /**\n* Test if the result satisfies a predicate.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A boolean result\n* @example\n* const result = Result.Ok(1);\n* const satisfied = result.satisfies(x => x === 1); // true\n*\n* const result = Result.Error(1);\n* const satisfied = result.satisfies(x => x === 1); // false\n*/\n    abstract satisfies(predicate: (x: T) => PromiseLike<boolean | T>): Promise<boolean>;\n    abstract satisfies(predicate: (x: T) => boolean | T): Promise<boolean>;\n    /**\n* Test if the result value equals another value.\n* Will only test the equality if the result is Ok.\n* @param value The value to test equality with\n* @returns A boolean result\n* @example\n* const result = Result.Ok(1);\n* const satisfied = result.valueEquals(1); // true\n*\n* const result = Result.Error(1);\n* const satisfied = result.valueEquals(1); // false\n*/\n    abstract valueEquals(value: T): Promise<boolean>;\n    /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will always return an Ok result even if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @see {@link transform} Alias\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n*\n* const result = Result.Error(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n*/\n    abstract map<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract map<Y = T>(λ: (x: T) => Y): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract map<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will always return an Ok result even if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @see {@link map} Alias\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.map((x) => undefined); // Result.Ok(undefined)\n*\n* const result = Result.Error(1);\n* const mapped = result.map((x) => ({age: x})); // Result.Error(1)\n*/\n    abstract transform<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract transform<Y = T>(λ: (x: T) => Y): AsyncResult<IfAnyOrUnknown<Y, any, Y>>;\n    abstract transform<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y>>;\n    /**\n* Map the result value.\n* Will only map the value if the result is Ok.\n* Will return an Error result if the passed value is undefined.\n* @param λ The function to map the value to\n* @returns A new result with the mapped value\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.expectMap((x) => ({age: x})); // Result.Ok({age: 1})\n*\n* const result = Result.Ok(1);\n* const mapped = result.expectMap((x) => undefined); // Result.Error()\n*\n* const result = Result.Error(1);\n* const mapped = result.expectMap((x) => ({age: x})); // Result.Error(1)\n*/\n    abstract expectMap<Y = T>(λ: (x: T) => PromiseLike<Optional<T>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => SyncResult<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Y): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract expectMap<Y = T>(λ: (x: T) => Y | PromiseLike<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    /**\n* Map the result value and flatten the result.\n* Will only map the value if the result is Ok.\n* @param λ The function to flat map the value to\n* @returns A new result with the flat mapped value\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.flatMap((x) => 5)); // Result.Ok(5)\n*\n* const result = Result.Error(1);\n* const mapped = result.flatMap((x) => 5)); // Result.Error(1)\n*\n* const result = Result.Ok(1);\n* const mapped = result.flatMap((x) => Result.Ok(5)); // Result.Ok(5)\n*/\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Optional<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Result<Y>>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => PromiseLike<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Optional<Y>): SyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => AsyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => SyncResult<Y>): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Result<Y>): Result<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => Y): AsyncResult<IfAnyOrUnknown<Y, any, Y & {}>>;\n    abstract flatMap<Y = T>(λ: (x: T) => any): Result<Y & {}>;\n    /**\n* Returns the result value if it is Ok, otherwise returns the error value.\n* @returns The result value or the error value\n* @example\n* const result = Result.Ok(5);\n* const value = result.merge(); // 5\n*\n* const result = Result.Error(10);\n* const value = result.merge(); // 10\n*/\n    abstract merge(): Promise<T>;\n    /**\n* Rejects the result if the predicate returns true.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const rejected = result.reject(x => x === 1); // Result.Error()\n*/\n    abstract reject(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n    abstract reject(predicate: (x: T) => boolean): AsyncResult<T>;\n    abstract reject(predicate: (x: T) => boolean | PromiseLike<boolean>): Result<T>;\n    /**\n* Filters the result if the predicate returns true.\n* Will only test the predicate if the result is Ok.\n* @param predicate The predicate to test\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const filtered = result.filter(x => x === 1); // Result.Ok(1)\n*\n* const result = Result.Ok(1);\n* const filtered = result.filter(x => x === 2); // Result.Error(2)\n*/\n    abstract filter<O extends T>(predicate: (x: T) => x is O): AsyncResult<O>;\n    abstract filter(predicate: (x: T) => PromiseLike<boolean>): AsyncResult<T>;\n    abstract filter(predicate: (x: T) => boolean): AsyncResult<T>;\n    abstract filter(predicate: (x: T) => boolean | PromiseLike<boolean>): Result<T>;\n    /**\n* Match the result type and return a value.\n* @param callbacks The callbacks to match\n* @returns The matched value\n* @example\n* const result = Result.Ok(1);\n* const value = result.match({\n*  Ok: (x) => 10,\n*  Error: (x) => 15\n* }); // 10\n*\n* const result = Result.Error(1);\n* const value = result.match({\n*  Ok: (x) => 10,\n*  Error: (x) => 15\n* }); // 15\n*/\n    abstract match<out_ok = T, out_error = T, out_abort = T>(callbacks: IResultCallbacks<T, out_ok, out_error, out_abort>): Promise<out_ok | out_error | out_abort>;\n    abstract match(callbacks: IResultCallbacks<T, T, T, T>): any;\n    /**\n* Aborts the excution if the result is an error with an error value.\n* @param λOrValue The function or value to set as error message if the result is an error\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const aborted = result.abortOnError(); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError(); // Result.Aborted()\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError('Error'); // Result.Aborted('Error')\n*/\n    abstract abortOnErrorWith(): AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: ((error: any) => PromiseLike<any>) | PromiseLike<any>): AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: Y | ((error: any) => any)): AsyncResult<T>;\n    abstract abortOnErrorWith<Y = any>(λOrValue: Y | ((error: any) => any)): Result<T>;\n    /**\n* Tap the error value if result is an error.\n* @param λ The function to tap the error value with\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const tapped = result.tapError(x => console.log(x)); // No logs!\n*\n* const result = Result.Error(1);\n* const tapped = result.tapError(x => console.log(x)); // Logs: \"1\"\n*/\n    abstract tapError(λ: (x: any) => PromiseLike<void>): AsyncResult<T>;\n    abstract tapError(λ: (x: any) => void): AsyncResult<T>;\n    abstract tapError(λ: (x: any) => void | PromiseLike<void>): Result<T>;\n    /**\n* Map the error value if result is an error.\n* @param λ The function to map the error value to\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const mapped = result.mapError(x => 10); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const mapped = result.mapError(x => 10); // Result.Error(10)\n*/\n    abstract mapError(λ: (x: any) => PromiseLike<any>): AsyncResult<T>;\n    abstract mapError(λ: (x: any) => any): AsyncResult<T>;\n    abstract mapError(λ: (x: any) => any): Result<T>;\n    /**\n* Recover the result if it is an error and the predicate returns true.\n* @param predicate The predicate to test\n* @param λ The function to recover the result with\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const recovered = result.recoverWhen(x => true, x => 10); // Result.Ok(10)\n*\n* const result = Result.Error(1);\n* const recovered = result.recoverWhen(x => false, x => 10); // Result.Error(1)\n*/\n    abstract recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => Y): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => PromiseLike<boolean | T>, λ: (x: T) => PromiseLike<Y>): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => boolean | T, λ: (x: T) => Y): AsyncResult<Y>;\n    abstract recoverWhen<Y = T>(predicate: (x: T) => boolean | T | PromiseLike<boolean | T>, λ: (x: T) => Y): Result<Y>;\n    /**\n* Aborts the excution if the result is an error.\n* @returns A new result\n* @example\n* const result = Result.Ok(1);\n* const aborted = result.abortOnError(); // Result.Ok(1)\n*\n* const result = Result.Error(1);\n* const aborted = result.abortOnError(); // Result.Aborted()\n*/\n    abstract abortOnError(): AsyncResult<T>;\n    /**\n* Converts the result to a asyncronous result.\n* @returns A new async result\n* @example\n* const result = Result.Ok(1);\n* const async = result.asynchronous(); // Result.Pending(Result.Ok(1))\n*\n* const result = Result.Error(1);\n* const async = result.asynchronous(); // Result.Pending(Result.Error(1))\n*/\n    abstract asynchronous(): AsyncResult<T>;\n    /**\n* Converts the result to a promise.\n* @returns A promise\n* @example\n* const result = Result.Ok(1);\n* const promise = result.promise(); // Promise<1>\n*/\n    abstract toPromise(): Promise<T>;\n    /**\n* Converts the result to an optional object.\n* @returns An optional\n* @example\n* const result = Result.Ok(1);\n* const optional = result.toOptional(); // Optional.Some(1)\n*\n* const result = Result.Error(1);\n* const optional = result.toOptional(); // Optional.None\n*/\n    abstract toOptional(): Promise<Optional<T>>;\n}\n","import returnThis from '@utils/return-this';\nimport Exception from '@utils/exception';\n\nimport { pipe, property } from '@utils/utils';\nimport { Optional } from '@optional/index';\nimport { Result } from '@generated/result.generated';\nimport { AsyncResult } from '@generated/asyncResult.generated';\n\nimport { IResultCallbacks } from '@src/result.types';\nimport { isAsyncResult } from './result.utils';\n\nexport class PendingClass<T> extends AsyncResult<T> {\n\n  promise: Promise<any>;\n  isAsynchronous = true as const;\n\n  constructor(promise: any) {\n    super();\n    this.promise = PendingClass.FindNextNonPending(promise);\n\n    this.makePropertyNonEnumerable('isOk');\n    this.makePropertyNonEnumerable('isError');\n    this.makePropertyNonEnumerable('isAborted');\n  }\n\n  get(): any {\n    return this.toPromise();\n  }\n\n  getOrElse(value?: any): Promise<any> {\n    return pipe(this.callWrappedResultMethod('getOrElse'), property(<any>'promise'))(value) as any;\n  }\n\n  recover(λ: (x: any) => any): AsyncResult<any> {\n    return this.callWrappedResultMethod('recover')(λ);\n  }\n\n  replace(value: any): AsyncResult<any> {\n    return this.callWrappedResultMethod('replace')(value);\n  }\n\n  expectProperty(propertyName: string): AsyncResult<any> {\n    return this.callWrappedResultMethod('expectProperty')(propertyName);\n  }\n\n  property(propertyName: string): AsyncResult<any> {\n    return this.callWrappedResultMethod('property')(propertyName);\n  }\n\n  tap(λ: (x: T) => any): AsyncResult<T> {\n    return this.callWrappedResultMethod('tap')(λ);\n  }\n\n  satisfies(predicate: (x: T) => any): Promise<boolean> {\n    return pipe(this.callWrappedResultMethod('satisfies'), property(<any>'promise'))(predicate) as any;\n  }\n\n  valueEquals(value: T): Promise<boolean> {\n    return pipe(this.callWrappedResultMethod('valueEquals'), property(<any>'promise'))(value) as any;\n  }\n\n  map(λ: (x: T) => any): AsyncResult<any> {\n    return this.callWrappedResultMethod('map')(λ);\n  }\n\n  transform(λ: (x: T) => any): AsyncResult<any> {\n    return this.map(λ);\n  }\n\n  expectMap(λ: (x: T) => any): any {\n    return this.callWrappedResultMethod('expectMap')(λ);\n  }\n\n  flatMap(λ: (x: T) => any): any {\n    return this.callWrappedResultMethod('flatMap')(λ);\n  }\n\n  merge(): Promise<T> {\n    return pipe(this.callWrappedResultMethod('merge'), property(<any>'promise'))() as any;\n  }\n\n  reject(predicate: (x: T) => any): any {\n    return this.callWrappedResultMethod('reject')(predicate);\n  }\n\n  filter(predicate: (x: T) => any): any {\n    return this.callWrappedResultMethod('filter')(predicate);\n  }\n\n  match(callbacks: IResultCallbacks<T, any, any, any>): any {\n    return pipe(this.callWrappedResultMethod('match'), property(<any>'promise'))(callbacks) as any;\n  }\n\n  abortOnErrorWith(λOrValue?: any): AsyncResult<T> {\n    return this.callWrappedResultMethod('abortOnErrorWith')(λOrValue);\n  }\n\n  tapError(λ: (x: T) => any): AsyncResult<T> {\n    return this.callWrappedResultMethod('tapError')(λ);\n  }\n\n  mapError(λ: (x: any) => any): AsyncResult<T> {\n    return this.callWrappedResultMethod('mapError')(λ);\n  }\n\n  recoverWhen(predicate: (x: T) => any, λ: (x: T) => any): AsyncResult<T> {\n    return this.callWrappedResultMethod('recoverWhen')(predicate, λ);\n  }\n\n  abortOnError(): AsyncResult<T> {\n    return this.callWrappedResultMethod('abortOnError')();\n  }\n\n  asynchronous(): AsyncResult<T> {\n    return returnThis.nullary.call(this) as any;\n  }\n\n  toPromise(): any {\n    return this.promise.then(Result.toPromise);\n  }\n\n  toOptional(): Promise<Optional<T>> {\n    return pipe(this.callWrappedResultMethod('toOptional'), property(<any>'promise'))() as any;\n  }\n\n  /**\n   * Calls a method on the wrapped result.\n   * if the promise is rejected, the result will be aborted.\n   * @param methodName The name of the method to call on the wrapped result\n   * @returns A function that calls the method on the wrapped result\n   * @example\n   * const pending = Result.Pending(Result.Ok(1));\n   * const method = pending.callWrappedResultMethod('get'); // Returns a function that calls Result.Ok(1).get()\n   * const result = method(); // Returns 1\n   */\n  private callWrappedResultMethod<Wrapped = Result<T>>(methodName: keyof Wrapped) {\n    return (...parameters: any[]) => Result.Pending(this\n      .promise\n      .then((<any>Result)[methodName](...parameters))\n      .catch(Result.Aborted));\n  };\n\n  /**\n   * Makes a property non enumerable\n   * @param propertyName The name of the property to make non enumerable\n   * @throws {Exception} If the property is accessed\n   */\n  private makePropertyNonEnumerable(propertyName: string) {\n    Object.defineProperty(this, propertyName, {\n      enumerable: false,\n      get: () => {\n        throw new Exception(`Cannot access '${propertyName}' of Result.Pending`);\n      },\n    });\n  }\n\n  /**\n   * Finds the next non-pending result in a promise chain\n   * @param promise The promise to unwrap\n   * @returns The unwrapped promise\n   * @example\n   * const pending = Result.Pending(\n   *  Result.Pending(\n   *    Promise.resolve(\n   *      'Hello World'\n   *    )\n   *  )\n   * );\n   * const result = await FindNextNonPending(pending.promise); // Returns 'Hello World'\n   */\n  private static async FindNextNonPending<T>(promise: PromiseLike<Result<T>> | PromiseLike<T>): Promise<Result<T> | T> {\n    const result = await promise;\n    if (isAsyncResult(result) && result instanceof PendingClass) {\n      return PendingClass.FindNextNonPending(result.promise);\n    }\n    return result as T;\n  }\n}\n","import { patchPrototype, instantiateWithFactory } from '@utils/factory';\nimport { Result } from '@generated/result.generated';\nimport { SyncResult } from '@generated/syncResult.generated';\nimport { AsyncResult } from '@generated/asyncResult.generated';\nimport { AbortedClass } from './aborted';\nimport { ErrorClass } from './error';\nimport { OkClass } from './ok';\nimport { PendingClass } from './pending';\n\n\n/**\n * Patch the function prototypes to inherit from their respective\n * Class prototypes\n */\nfunction patchFactoryFunctions() {\n  patchPrototype(Ok, OkClass);\n  patchPrototype(Error, ErrorClass);\n  patchPrototype(Aborted, AbortedClass);\n  patchPrototype(Pending, PendingClass);\n}\n\nexport const Aborted = function makeAborted(message?: any): SyncResult<any> {\n  return instantiateWithFactory(AbortedClass, Aborted, message);\n};\n\nexport const Error = function makeError(message?: any): SyncResult<any> {\n  return instantiateWithFactory(ErrorClass, Error, message);\n};\n\nexport const Ok = function makeOk<T>(value?: T): SyncResult<T> {\n  return instantiateWithFactory(OkClass<T>, Ok, value);\n};\n\nexport const Pending = function makePending<T>(promise: PromiseLike<Result<T>> | PromiseLike<T>): AsyncResult<T> {\n  return instantiateWithFactory(PendingClass<T>, Pending, promise);\n};\n\npatchFactoryFunctions();\n","import { Result } from '@generated/result.generated';\r\n\r\nimport { AbortedClass } from './aborted';\r\nimport { ErrorClass } from './error';\r\nimport { OkClass } from './ok';\r\nimport { PendingClass } from './pending';\r\n\r\nimport { Ok, Error, Aborted, Pending } from './result.factory';\r\n\r\nfunction addStaticProperties() {\r\n  Result.Ok = Ok;\r\n  Result.Error = Error;\r\n  Result.Aborted = Aborted;\r\n  Result.Pending = Pending;\r\n}\r\n\r\naddStaticProperties();\r\n\r\nexport {\r\n  OkClass,\r\n  ErrorClass,\r\n  AbortedClass,\r\n  PendingClass,\r\n  Result\r\n};\r\n"],"names":["isObject","isFunction","when","global","patchFactoryFunctions","addStaticProperties","pipe","Error"],"mappings":"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CA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,WAAW,CAAC,KAAK,EAAE;IAC5B,EAAE,OAAO,KAAK,IAAI,IAAI,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACvE,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,iBAAiB,CAAC,KAAK,EAAE;IAClC,EAAE,OAAO,YAAY,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,KAAK,CAAC,CAAC;IACnD,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,UAAU,CAAC,KAAK,EAAE;IAC3B;IACA;IACA,EAAE,IAAI,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;IAC9D,EAAE,OAAO,GAAG,IAAI,OAAO,IAAI,GAAG,IAAI,MAAM,CAAC;IACzC,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,QAAQ,CAAC,KAAK,EAAE;IACzB,EAAE,OAAO,OAAO,KAAK,IAAI,QAAQ;IACjC,IAAI,KAAK,GAAG,CAAC,CAAC,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,gBAAgB,CAAC;IAC9D,CAAC;AACD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,SAAS,QAAQ,CAAC,KAAK,EAAE;IACzB,EAAE,IAAI,IAAI,GA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"}