import ts from 'typescript';

import { InterfaceVisitorByType } from './utils/interfaceVisitorByType.js';
import { SignatureVisitorByClassOrInterface } from './utils/signatureVisitorByInterface.js';

import { GenericDefinition, MethodProperty, retriveInfoOnMethod } from './utils/utils.method.js';

const filePathToInterface = './src/result.types.ts';
const interfaceName = 'IResult';
const inheritClassName = 'Result';

const generatedFileName = 'asyncResult.generated.ts';
const generatedClassName = 'AsyncResult';

const keepReturnTypes = ['AsyncResult', 'Promise']

const warning = `
// ========================================================
// This file is generated by asyncResult.gen.ts
// Do not edit this file directly
// ========================================================
`;

const importStatments = `
/* eslint-disable @typescript-eslint/ban-types */
import { IResultCallbacks } from '@src/result.types';
import { IfAny, IfAnyOrUnknown } from '@utils/types';
import { Optional } from './optional.generated';
import { Result } from './result.generated';
import { SyncResult } from './syncResult.generated';
`;

const classComment = `
/**
 * A result that can be awaited.
 * Contrary to the SyncResult, this result object contains
 * a promise that can be awaited. When used, the entire current
 * chain of result will be converted to AsyncResult.
 * @template T The type of the value of the result
 * @see {@link SyncResult} for a synchronous version of this class
 * @see {@link Result} for a result that can be both asynchronous and synchronous
 * @example
 * const result = Result
 *  .expect(Promise.resolve('hello world'))
 *  .toPromise();
 *
 * const value = await result; // 'hello world'
 */
`;

const interfaceTemplate = (name: string, content: string) => {
  return `export abstract class ${name}<T = any> extends ${inheritClassName}<T> {
        ${content}
    }`;
};

const templateFuncDeclaration = (
  name: string,
  types: GenericDefinition[],
  parameters: MethodProperty[],
  returnStr?: string,
  comment = ''
) => {
  const typesUnique = [...new Set(types)];
  const parametersUnique = [...new Set(parameters)];

  const parmsStr = parametersUnique
    .map(({ name, type, isOptional }) => `${name}${isOptional ? '?':''}: ${type}`)
    .join(', ')
    .trim();

  return `
        ${comment}
          abstract ${name}<${typesUnique.map(type => type.fullValue).join(', ')}>(${parmsStr}): ${returnStr};
      `.trimEnd();
};


const program = ts.createProgram([filePathToInterface], {});
const checker = program.getTypeChecker();

const sourceFile = program.getSourceFile(filePathToInterface);

const nodes = InterfaceVisitorByType.getAll(sourceFile!, interfaceName);
const methods = SignatureVisitorByClassOrInterface.getAll(nodes[0]);

const signatures = methods.map((node) =>
  retriveInfoOnMethod(checker, sourceFile!, node));

const funcs = signatures
  .map(({ name, generics, parameters, returnType, documentation }) => {
    const newReturnTypes = returnType.subTypes.filter(subType => keepReturnTypes.find((allowed) => subType.startsWith(allowed)))
    const newReturnType = (newReturnTypes.length === 0 ? returnType.subTypes : newReturnTypes).join('|');

    return templateFuncDeclaration(name, generics, parameters, newReturnType, documentation.raw?.fullRaw ?? '');
  })
  .join('');

const fileContents = `
    ${warning}
    ${importStatments}
    ${classComment}
    ${interfaceTemplate(generatedClassName, `${funcs}`)}
`;

const resultFile = ts.createSourceFile(
  generatedFileName,
  fileContents,
  ts.ScriptTarget.ESNext,
  false,
  ts.ScriptKind.TS
);
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

ts.sys.writeFile(
  `./src/generated/${resultFile.fileName}`,
  printer.printFile(resultFile)
);
