import ts from 'typescript';
import _ from 'lodash';
import merge from 'deepmerge';

import {
  createComment,
  createTypeOverload,
  TypeOverloadByParametersObjToStr,
} from './utils/utils.js';
import { getAllMethodsByFileAndName } from './utils/utils.method.js';

const filePathToInterface = './src/optional.types.ts';
const interfaceName = 'IOptional';

const generatedFileName = 'optional.generated.ts';
const generatedClassName = 'Optional';

const instanceParam: [string, string, string[]] = [
  'optional',
  'IOptional<T>',
  ['T'],
];
const instance = '(<any>Optional.Some)()';

const warning = `
// ========================================================
// This file is generated by optional.gen.ts
// Do not edit this file directly
// ========================================================
`;

const importStatments = `
/* eslint-disable @typescript-eslint/ban-types */
import { CreateSomeFunc, CreateNoneFunc, IOptional, IOptionalMatchClauses, NullableTransformationFunction, NullaryValueFactory, Predicate, SideEffectsFunction, TransformationFunction } from '@src/optional.types';
import { fromNullable, all, values, first, fromParsedJson, when, isOptional, isSome, isNone } from '@optional/optional.utils';
import { IfAnyOrUnknown, IfAny, IfNullOrUndefined } from '@utils/types';
import returnThis from '@utils/return-this';
`;

const baseFunctions = `
isOptionalInstance = true as const;
valuePresent: boolean = false;
valueAbsent: boolean = false;
value?: T;
static Some: CreateSomeFunc;
static None: CreateNoneFunc;
static fromNullable = fromNullable;
static fromParsedJson = fromParsedJson;
static all = all;
static values = values;
static when = when;
static first = first;
static isOptional = isOptional;
static isSome = isSome;
static isNone = isNone;
`;

const instanceParameterComment = `The instance parameter to use as a base to call the functions with.`;

const classTemplate = (name: string, content: string) => {
  return `export abstract class ${name}<T = any> implements ${interfaceName}<T> {
        ${content}
    }`;
};

const templatefuncImplementation = (
  name: string,
  type: string,
  maxParams: number,
  comment?: string
) => {
  const commentFormated = createComment(comment);

  return `
        ${commentFormated}
        static ${name}: ${type} = <T>(...params: any[]): any => {
            if(params.length < ${maxParams}) {
                return (...subParams: any[]) => (${generatedClassName}.${name} as any)(...[...params, ...subParams]);
            }

            const instance = params.splice(${maxParams - 1}, 1)[0];
            return (instance ?? ${instance}).${name}(...params);
        }
    `.trimEnd();
};

const program = ts.createProgram([filePathToInterface], {});
const checker = program.getTypeChecker();

const sourceFile = program.getSourceFile(filePathToInterface);

const signatures = getAllMethodsByFileAndName(sourceFile!, checker, interfaceName, true);
const signaturesGrouped = _.groupBy(signatures, 'name');

const abstractMethods =_.map(signaturesGrouped, (signatures, name) => {
  const methods = _.map(signatures, (signature) => {
    return `${signature.documentation.raw?.fullRaw ?? ''} ${signature.content}`;
  });
  methods.push(`
    ${name}(...args: any[]): any {
      return returnThis.any.call(this, ...args);
    }
  `);
  return methods.join('\n');
}).join('\n');

const funcs = _.map(signaturesGrouped, (value, name) => {
  let paramsCount = 0;
  let types: Record<string, any> = {}
  let comment: string | undefined;
  _.forEach(value, (signature) => {
    const { generics, parameters, returnType } = signature;
    paramsCount = Math.max(paramsCount, parameters.length);
    comment = signature.documentation.method;

    signature.documentation.fields = {
      ...signature.documentation.fields,
      ...{ [instanceParam[0]]: instanceParameterComment },
    };

    const newOverload = createTypeOverload(
      [
        ...parameters,
        {
          name: instanceParam[0],
          type: instanceParam[1],
          consumedTypes: instanceParam[2],
          documentation: instanceParameterComment,
          isOptional: false,
        },
      ],
      [{ name: 'T', fullValue: 'T' }, ...generics],
      returnType.type,
      signature.documentation
    );

    types = merge(types, newOverload);

  });

  return templatefuncImplementation(
    name,
    TypeOverloadByParametersObjToStr(types),
    paramsCount + 1,
    comment
  );
}).join('');

const fileContents = `
    ${warning}
    ${importStatments}
    ${classTemplate(generatedClassName, `${baseFunctions}${funcs}${abstractMethods}`)}
`;

const resultFile = ts.createSourceFile(
  generatedFileName,
  fileContents,
  ts.ScriptTarget.ESNext,
  false,
  ts.ScriptKind.TS
);
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

ts.sys.writeFile(
  `./src/generated/${resultFile.fileName}`,
  printer.printFile(resultFile)
);
