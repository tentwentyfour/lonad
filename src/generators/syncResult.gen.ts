import ts from 'typescript';
import _ from 'lodash';
import utils from 'util';

import { InterfaceVisitorByType } from './utils/interfaceVisitorByType.js';
import { SignatureVisitorByClassOrInterface } from './utils/signatureVisitorByInterface.js';

import { GenericDefinition, MethodProperty, retriveInfoOnMethod } from './utils/utils.method.js';

const filePathToInterface = './src/result.types.ts';
const interfaceName = 'IResult';
const inheritClassName = 'Result';

const generatedFileName = 'syncResult.generated.ts';
const generatedClassName = 'SyncResult';

const removedReturnTypes = ['AsyncResult', 'Promise']

const warning = `
// ========================================================
// This file is generated by syncResult.gen.ts
// Do not edit this file directly
// ========================================================
`;

const importStatments = `
/* eslint-disable @typescript-eslint/ban-types */
import { IResultCallbacks } from "@src/result.types";
import { AsyncResult } from "./asyncResult.generated";
import { Result } from "./result.generated";
import { Optional } from "./optional.generated";
import returnThis from "@utils/return-this";
import { IfAnyOrUnknown, IfAny } from '@utils/types';
`;

const classComment = `
/**
 * A result that is not awaitable.
 * Contrary to the AsyncResult, this result object does not contain
 * a promise that can be awaited.
 * @template T The type of the value of the result
 * @see {@link AsyncResult} for an awaitable result
 * @see {@link Result} for a result that can be both asynchronous and synchronous
 * @example
 * const result = Result
 *  .expect('hello world');
 *
 * const value = result.get(); // 'hello world'
 */
`;

const interfaceTemplate = (name: string, content: string) => {
  return `export abstract class ${name}<T = any> extends ${inheritClassName}<T>  {
        ${content}
    }`;
};

const templateFuncDeclaration = (
  name: string,
  types: GenericDefinition[],
  parameters: MethodProperty[],
  returnStr?: string,
  comment = ''
) => {
  const typesUnique = [...new Set(types)];
  const parametersUnique = [...new Set(parameters)];

  const parmsStr = parametersUnique
    .map(({ name, type, isOptional }) => `${name}${isOptional ? '?':''}: ${type}`)
    .join(', ')
    .trim();

  return `
          ${comment}
          ${name}<${typesUnique.map(type => type.fullValue).join(', ')}>(${parmsStr}): ${returnStr};
      `.trimEnd();
};


const program = ts.createProgram([filePathToInterface], {});
const checker = program.getTypeChecker();

const sourceFile = program.getSourceFile(filePathToInterface);

const nodes = InterfaceVisitorByType.getAll(sourceFile!, interfaceName);
const methods = SignatureVisitorByClassOrInterface.getAll(nodes[0]);

const signatures = methods.map((node) =>
  retriveInfoOnMethod(checker, sourceFile!, node));

const signaturesGrouped = _.groupBy(signatures, 'name');
const funcs =_.map(signaturesGrouped, (signatures, name) => {
  const methods = _.map(signatures, (signature) => {
    const { name, generics, parameters, returnType, documentation } = signature;
    const newReturnTypes = returnType.subTypes.filter(subType => !removedReturnTypes.find((deny) => subType.startsWith(deny)))
    const newReturnType = (newReturnTypes.length === 0 ? returnType.subTypes : newReturnTypes).join('|');

    return templateFuncDeclaration(name, generics, parameters, newReturnType, documentation.raw?.fullRaw ?? '');
  });
  methods.push(`
    ${name}(...args: any[]): any {
      return returnThis.any.call(this, ...args);
    }
  `);
  return methods.join('\n');
}).join('\n');

const fileContents = `
    ${warning}
    ${importStatments}
    ${classComment}
    ${interfaceTemplate(generatedClassName, `${funcs}`)}
`;

const resultFile = ts.createSourceFile(
  generatedFileName,
  fileContents,
  ts.ScriptTarget.ESNext,
  false,
  ts.ScriptKind.TS
);
const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

ts.sys.writeFile(
  `./src/generated/${resultFile.fileName}`,
  printer.printFile(resultFile)
);
